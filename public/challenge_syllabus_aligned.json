[
  {
    "day": 1,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Insert an Element in an Array",
      "description": "Problem: Write a C program to insert an element x at a given 1-based position pos in an array of n integers. Shift existing elements to the right to make space.\n\nInput:\n- First line: integer n (1 <= n <= 100)\n- Second line: n space-separated integers (the array)\n- Third line: integer pos (1 <= pos <= n+1)\n- Fourth line: integer x (element to insert)\n\nOutput:\n- Print the updated array (n+1 integers) in a single line, space-separated.\n\nExample:\nInput:\n5\n1 2 4 5 6\n3\n3\nOutput:\n1 2 3 4 5 6"
    },
    "question2": {
      "name": "Two Sum",
      "link": "https://leetcode.com/problems/two-sum/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Basics",
      "Hash Tables"
    ],
    "solutions": {
      "question1": [
          {
          "type": "tutorial",
          "explanation": "To insert an element at a specific position in an array:\n\n1. Shift all elements from position 'pos' to the end, one step to the right\n2. Insert the new element at the specified position\n3. The array size increases by 1\n\nKey Points:\n- Start shifting from the end to avoid overwriting values\n- Position is 1-based, but array indexing is 0-based\n- Ensure the array has enough space",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, pos, x;\n    int arr[101];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    scanf(\"%d %d\", &pos, &x);\n\n    for (int i = n; i >= pos; i--) {\n        arr[i] = arr[i - 1];\n    }\n\n    arr[pos - 1] = x;\n\n    for (int i = 0; i <= n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Solution Article",
          "link": "https://yourblog.com/day1-insert-element-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "NeetCode Explanation",
          "link": "https://www.youtube.com/watch?v=KLlXCFG5TnA"
        },
        {
          "explanation": "Find two numbers that add up to target using a hash map.\n\nApproach:\n1. Use hash map to store seen numbers\n2. For each number, check if (target - number) exists\n3. If found, return indices\n4. If not found, add to hash map\n\nWhy it works:\n- Hash map lookup is O(1)\n- Only one pass through array needed\n- Space-time tradeoff for efficiency",
          "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            \n            if (seen.find(complement) != seen.end()) {\n                return {seen[complement], i};\n            }\n            \n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "type": "tutorial"
        }
      ]
    }
  },
  {
    "day": 2,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Delete an Element from an Array",
      "description": "Problem: Write a C program to delete the element at a given 1-based position pos from an array of n integers. Shift remaining elements to the left.\n\nInput:\n- First line: integer n (1 <= n <= 100)\n- Second line: n space-separated integers\n- Third line: integer pos (1 <= pos <= n)\n\nOutput:\n- Print the updated array with (n-1) elements.\n\nExample:\nInput:\n5\n10 20 30 40 50\n2\nOutput:\n10 30 40 50"
    },
    "question2": {
      "name": "Best Time to Buy and Sell Stock",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Operations",
      "Math"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To delete an element from an array at a given position:\n\n1. Shift all elements after position 'pos' one step to the left\n2. This overwrites the element to be deleted\n3. Reduce the array size by 1\n\nKey Points:\n- Start shifting from the deletion position forward\n- No need to clear the last element (it's now outside array bounds)\n- Position is 1-based for input, but array uses 0-based indexing",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, pos;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    scanf(\"%d\", &pos);\n    \n    // Shift elements left\n    for (int i = pos - 1; i < n - 1; i++) {\n        arr[i] = arr[i + 1];\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 2) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Solution Walkthrough",
          "link": "https://yourblog.com/day2-delete-element-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Video Tutorial",
          "link": "https://www.youtube.com/watch?v=1pkOgXD63yU"
        },
        {
          "explanation": "Find maximum profit from buying and selling stock once.\n\nAlgorithm:\n1. Track minimum price seen so far\n2. For each price, calculate profit if selling today\n3. Update maximum profit\n\nKey Insight:\n- Buy at lowest price before current day\n- Sell at current price for maximum profit\n- One pass solution",
          "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int minPrice = INT_MAX;\n        int maxProfit = 0;\n        \n        for (int price : prices) {\n            minPrice = min(minPrice, price);\n            maxProfit = max(maxProfit, price - minPrice);\n        }\n        \n        return maxProfit;\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "type": "tutorial"
        },
        {
          "type": "editorial",
          "label": "LeetCode Editorial",
          "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/editorial/"
        }
      ]
    }
  },
  {
    "day": 3,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Linear Search with Comparison Count",
      "description": "Problem: Implement linear search on an array. Search for key k and count how many comparisons were performed.\n\nInput:\n- First line: n\n- Second line: array elements\n- Third line: k\n\nOutput:\n- Found at index i OR Not Found\n- Comparisons = c\n\nExample:\n5\n10 20 30 40 50\n30\nOutput:\nFound at index 2\nComparisons = 3"
    },
    "question2": {
      "name": "Missing number in array",
      "link": "https://practice.geeksforgeeks.org/problems/missing-number-in-array/0",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Searching"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linear search checks each element sequentially until finding the target or reaching the end.\n\nAlgorithm:\n1. Iterate through each element of the array\n2. Compare current element with the search key\n3. If found, return the index\n4. If not found after checking all elements, return -1\n\nKey Points:\n- Works on unsorted arrays\n- Time complexity is O(n) in worst case\n- Count comparisons to analyze performance",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, k, comparisons = 0;\n    int arr[100];\n    int found = -1;\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    scanf(\"%d\", &k);\n    \n    for (int i = 0; i < n; i++) {\n        comparisons++;\n        if (arr[i] == k) {\n            found = i;\n            break;\n        }\n    }\n    \n    if (found != -1) {\n        printf(\"Found at index %d\\n\", found);\n    } else {\n        printf(\"Not Found\\n\");\n    }\n    printf(\"Comparisons = %d\\n\", comparisons);\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Algorithm Explanation",
          "link": "https://yourblog.com/day3-linear-search-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "GFG Video Solution",
          "link": "https://www.youtube.com/watch?v=example-missing-number"
        },
        {
          "explanation": "Find missing number using sum formula or XOR.\n\nApproach 1 - Sum Formula:\n1. Calculate expected sum: n*(n+1)/2\n2. Calculate actual sum\n3. Difference is missing number\n\nApproach 2 - XOR:\n1. XOR all indices with all array values\n2. Pairs cancel out, leaving missing number",
          "code": "class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int n = nums.size();\n        int expectedSum = n * (n + 1) / 2;\n        int actualSum = 0;\n        \n        for (int num : nums) {\n            actualSum += num;\n        }\n        \n        return expectedSum - actualSum;\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "type": "tutorial"
        },
        {
          "type": "editorial",
          "label": "GeeksforGeeks Article",
          "link": "https://www.geeksforgeeks.org/find-the-missing-number/"
        }
      ]
    }
  },
  {
    "day": 4,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Reverse an Array In-Place",
      "description": "Problem: Reverse an array using two-pointer approach.\n\nInput:\n- n\n- n elements\n\nOutput:\n- reversed array\n\nExample:\n5\n1 2 3 4 5\nOutput:\n5 4 3 2 1"
    },
    "question2": {
      "name": "Remove Element",
      "link": "https://leetcode.com/problems/remove-element/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Reversal",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Reverse an array using the two-pointer technique:\n\n1. Use two pointers: one at start (left) and one at end (right)\n2. Swap elements at left and right pointers\n3. Move left pointer forward and right pointer backward\n4. Continue until left >= right\n\nKey Points:\n- In-place reversal (no extra array needed)\n- Efficient with O(n/2) swaps\n- Works for arrays of any size",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Two-pointer reversal\n    int left = 0, right = n - 1;\n    while (left < right) {\n        int temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Two-Pointer Approach",
          "link": "https://yourblog.com/day4-reverse-array-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Video Explanation",
          "link": "https://www.youtube.com/watch?v=example-remove-element"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Remove Element:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "LeetCode Editorial",
          "link": "https://leetcode.com/problems/remove-element/editorial/"
        }
      ]
    }
  },
  {
    "day": 5,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Merge Two Sorted Arrays",
      "description": "Problem: Merge two sorted arrays using two-pointer technique.\n\nInput:\n- n1, array1\n- n2, array2\n\nOutput:\n- merged sorted array"
    },
    "question2": {
      "name": "Merge Sorted Array",
      "link": "https://leetcode.com/problems/merge-sorted-array/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Merge",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Merge two sorted arrays using two-pointer technique:\n\n1. Use pointers i and j for array1 and array2\n2. Compare elements at both pointers\n3. Add smaller element to result and move that pointer\n4. When one array is exhausted, copy remaining elements from other array\n\nKey Points:\n- Maintains sorted order\n- Time complexity O(n + m)\n- Requires extra space for result array",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n1, n2;\n    int arr1[100], arr2[100], result[200];\n    \n    scanf(\"%d\", &n1);\n    for (int i = 0; i < n1; i++) {\n        scanf(\"%d\", &arr1[i]);\n    }\n    \n    scanf(\"%d\", &n2);\n    for (int i = 0; i < n2; i++) {\n        scanf(\"%d\", &arr2[i]);\n    }\n    \n    int i = 0, j = 0, k = 0;\n    while (i < n1 && j < n2) {\n        if (arr1[i] <= arr2[j]) {\n            result[k++] = arr1[i++];\n        } else {\n            result[k++] = arr2[j++];\n        }\n    }\n    \n    while (i < n1) result[k++] = arr1[i++];\n    while (j < n2) result[k++] = arr2[j++];\n    \n    for (int i = 0; i < k; i++) {\n        printf(\"%d\", result[i]);\n        if (i < k - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(n + m)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "LeetCode Video",
          "link": "https://www.youtube.com/watch?v=example2"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Merge Sorted Array:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 6,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Remove Duplicates from Sorted Array",
      "description": "Problem: Given a sorted array, remove duplicates and print only unique elements.\nExample:\n6\n1 1 2 2 3 3\nOutput:\n1 2 3"
    },
    "question2": {
      "name": "Move Zeroes",
      "link": "https://leetcode.com/problems/move-zeroes/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Cleanup"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To delete an element from an array at a given position:\n\n1. Shift all elements after position 'pos' one step to the left\n2. This overwrites the element to be deleted\n3. Reduce the array size by 1\n\nKey Points:\n- Start shifting from the deletion position forward\n- No need to clear the last element (it's now outside array bounds)\n- Position is 1-based for input, but array uses 0-based indexing",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, pos;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    scanf(\"%d\", &pos);\n    \n    // Shift elements left\n    for (int i = pos - 1; i < n - 1; i++) {\n        arr[i] = arr[i + 1];\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 2) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Move Zeroes - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Move+Zeroes+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Move Zeroes:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 7,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Recursive Fibonacci",
      "description": "Problem: Implement recursive Fibonacci.\nInput: n\nOutput: fib(n)\nExample:\n6 \u2192 8"
    },
    "question2": {
      "name": "Fibonacci Number",
      "link": "https://leetcode.com/problems/fibonacci-number/",
      "difficulty": "Easy"
    },
    "topics": [
      "Recursion"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Recursive solution for Recursive Fibonacci:\n\n1. Define base case(s)\n2. Define recursive case\n3. Ensure progress toward base case\n\nKey Points:\n- Recursion uses call stack\n- Watch for stack overflow with large inputs\n- Consider iterative alternative for better space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint solve(int n) {\n    // Base case\n    if (n <= 1) return n;\n    \n    // Recursive case\n    return solve(n - 1) + solve(n - 2);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    printf(\"%d\\n\", solve(n));\n    return 0;\n}",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Fibonacci Number - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Fibonacci+Number+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Fibonacci Number:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 8,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Compute Power Using Recursion",
      "description": "Problem: Compute a^b using recursion.\nExample:\n2 5 \u2192 32"
    },
    "question2": {
      "name": "Power of Two",
      "link": "https://leetcode.com/problems/power-of-two/",
      "difficulty": "Easy"
    },
    "topics": [
      "Recursion",
      "Math"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Compute Power Using Recursion:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Power of Two - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Power+of+Two+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Power of Two:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 9,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Reverse a String",
      "description": "Problem: Reverse a string using two-pointer swapping.\nExample:\nhello \u2192 olleh"
    },
    "question2": {
      "name": "Reverse String",
      "link": "https://leetcode.com/problems/reverse-string/",
      "difficulty": "Easy"
    },
    "topics": [
      "String",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Reverse an array using the two-pointer technique:\n\n1. Use two pointers: one at start (left) and one at end (right)\n2. Swap elements at left and right pointers\n3. Move left pointer forward and right pointer backward\n4. Continue until left >= right\n\nKey Points:\n- In-place reversal (no extra array needed)\n- Efficient with O(n/2) swaps\n- Works for arrays of any size",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Two-pointer reversal\n    int left = 0, right = n - 1;\n    while (left < right) {\n        int temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Reverse String - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Reverse+String+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Reverse String:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 10,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Check Palindrome",
      "description": "Problem: Check if a string is palindrome using two pointers.\nExample:\nlevel \u2192 YES"
    },
    "question2": {
      "name": "Reverse Linked List",
      "link": "https://leetcode.com/problems/reverse-linked-list/",
      "difficulty": "Easy"
    },
    "topics": [
      "Palindrome Check"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Check Palindrome:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Reverse Linked List - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Reverse+Linked+List+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Reverse Linked List:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 11,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Matrix Addition",
      "description": "Problem: Compute transpose of an m\u00d7n matrix."
    },
    "question2": {
      "name": "Transpose Matrix",
      "link": "https://leetcode.com/problems/transpose-matrix/",
      "difficulty": "Easy"
    },
    "topics": [
      "Matrix"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Matrix Addition:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Transpose Matrix - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Transpose+Matrix+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Transpose Matrix:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 12,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Check Symmetric Matrix",
      "description": "Problem: Check if all diagonals of matrix contain same values."
    },
    "question2": {
      "name": "Toeplitz Matrix",
      "link": "https://leetcode.com/problems/toeplitz-matrix/",
      "difficulty": "Easy"
    },
    "topics": [
      "Matrix Diagonal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Check Symmetric Matrix:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Toeplitz Matrix - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Toeplitz+Matrix+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Toeplitz Matrix:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 13,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Spiral Order Traversal",
      "description": "Problem: Print matrix in spiral order."
    },
    "question2": {
      "name": "Spiral Matrix",
      "link": "https://leetcode.com/problems/spiral-matrix/",
      "difficulty": "Medium"
    },
    "topics": [
      "Matrix Spiral"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Spiral Order Traversal:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Spiral Matrix - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Spiral+Matrix+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Spiral Matrix:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 14,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Rotate Matrix 90 Degrees",
      "description": "Problem: Rotate an NxN matrix by 90\u00b0 clockwise."
    },
    "question2": {
      "name": "Rotate Image",
      "link": "https://leetcode.com/problems/rotate-image/",
      "difficulty": "Medium"
    },
    "topics": [
      "Matrix Rotation"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Rotate Matrix 90 Degrees:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Rotate Image - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Rotate+Image+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Rotate Image:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 15,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Matrix Diagonal Sum",
      "description": "Problem: If any cell is 0, set its row and column to 0."
    },
    "question2": {
      "name": "Set Matrix Zeroes",
      "link": "https://leetcode.com/problems/set-matrix-zeroes/",
      "difficulty": "Medium"
    },
    "topics": [
      "Matrix"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Matrix Diagonal Sum:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Set Matrix Zeroes - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Set+Matrix+Zeroes+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Set Matrix Zeroes:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 16,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Frequency Counter in Array",
      "description": "Count frequency of each value in array (0\u2013100)."
    },
    "question2": {
      "name": "Design HashMap",
      "link": "https://leetcode.com/problems/design-hashmap/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Count",
      "HashMap Logic"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Frequency Counter in Array:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Design HashMap - Video Solution",
          "link": "https://www.youtube.com/watch?v=cNWsgbKwwoU"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Design HashMap:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 17,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Find Maximum and Minimum Element",
      "description": "Problem: Find max sum of subarray using Kadane\u2019s algorithm."
    },
    "question2": {
      "name": "Maximum Subarray",
      "link": "https://leetcode.com/problems/maximum-subarray/",
      "difficulty": "Medium"
    },
    "topics": [
      "Kadane",
      "DP Intro"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Find Maximum and Minimum Element:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Maximum Subarray - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Maximum+Subarray+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Maximum Subarray:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 18,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Rotate Array by K Positions",
      "description": "Use prefix & suffix arrays to compute product except self."
    },
    "question2": {
      "name": "Product of Array Except Self",
      "link": "https://leetcode.com/problems/product-of-array-except-self/",
      "difficulty": "Medium"
    },
    "topics": [
      "Prefix Suffix",
      "Array"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Rotate Array by K Positions:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Product of Array Except Self - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Product+of+Array+Except+Self+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Product of Array Except Self:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 19,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Check Pair with Given Sum",
      "description": "Use two-pointer technique to compute maximum area."
    },
    "question2": {
      "name": "Container With Most Water",
      "link": "https://leetcode.com/problems/container-with-most-water/",
      "difficulty": "Medium"
    },
    "topics": [
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Check Pair with Given Sum:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Container With Most Water - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Container+With+Most+Water+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Container With Most Water:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 20,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "3-Sum Triplets",
      "description": "Find triplets that sum to zero using sorting + two pointers."
    },
    "question2": {
      "name": "3Sum",
      "link": "https://leetcode.com/problems/3sum/",
      "difficulty": "Medium"
    },
    "topics": [
      "Sorting",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for 3-Sum Triplets:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "3Sum - Video Solution",
          "link": "https://www.youtube.com/results?search_query=3Sum+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for 3Sum:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 21,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Create and Traverse Singly Linked List",
      "description": "Problem: Implement a singly linked list using dynamic memory allocation. Read n integers, insert each at the end of the list, then print the list.\n\nInput:\n- First line: n (1 <= n <= 100)\n- Second line: n integers\n\nOutput:\n- Elements of the list printed in order."
    },
    "question2": {
      "name": "Middle of the Linked List",
      "link": "https://leetcode.com/problems/middle-of-the-linked-list/",
      "difficulty": "Easy"
    },
    "topics": [
      "Linked List Basics",
      "Traversal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linked List solution for Create and Traverse Singly Linked List:\n\n1. Define node structure\n2. Traverse the list as needed\n3. Modify pointers carefully\n\nKey Points:\n- Always check for NULL pointers\n- Draw diagrams to visualize pointer changes\n- Free memory when deleting nodes",
          "code": "#include &lt;stdio.h&gt;\n\n #include<stdlib> \n struct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    \n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Middle of the Linked List - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Middle+of+the+Linked+List+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Middle of the Linked List:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 22,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Reverse a Singly Linked List (Iterative)",
      "description": "Problem: Reverse a singly linked list using three pointers: prev, curr, next.\n\nInput:\n- n and n elements\n\nOutput:\n- Reversed list.\n\nExample:\n5 \u2192 1 2 3 4 5 \u2192 5 4 3 2 1"
    },
    "question2": {
      "name": "Reverse Linked List",
      "link": "https://leetcode.com/problems/reverse-linked-list/",
      "difficulty": "Easy"
    },
    "topics": [
      "Linked List",
      "Reversal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Reverse an array using the two-pointer technique:\n\n1. Use two pointers: one at start (left) and one at end (right)\n2. Swap elements at left and right pointers\n3. Move left pointer forward and right pointer backward\n4. Continue until left >= right\n\nKey Points:\n- In-place reversal (no extra array needed)\n- Efficient with O(n/2) swaps\n- Works for arrays of any size",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Two-pointer reversal\n    int left = 0, right = n - 1;\n    while (left < right) {\n        int temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Reverse Linked List - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Reverse+Linked+List+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Reverse Linked List:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 23,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Merge Two Sorted Linked Lists",
      "description": "Problem: Merge two sorted linked lists into a single sorted list using pointer manipulation only.\n\nInput:\n- n1, list1\n- n2, list2\n\nOutput:\n- Sorted merged list."
    },
    "question2": {
      "name": "Merge Two Sorted Lists",
      "link": "https://leetcode.com/problems/merge-two-sorted-lists/",
      "difficulty": "Easy"
    },
    "topics": [
      "Linked List",
      "Merge Operation"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Merge two sorted arrays using two-pointer technique:\n\n1. Use pointers i and j for array1 and array2\n2. Compare elements at both pointers\n3. Add smaller element to result and move that pointer\n4. When one array is exhausted, copy remaining elements from other array\n\nKey Points:\n- Maintains sorted order\n- Time complexity O(n + m)\n- Requires extra space for result array",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n1, n2;\n    int arr1[100], arr2[100], result[200];\n    \n    scanf(\"%d\", &n1);\n    for (int i = 0; i < n1; i++) {\n        scanf(\"%d\", &arr1[i]);\n    }\n    \n    scanf(\"%d\", &n2);\n    for (int i = 0; i < n2; i++) {\n        scanf(\"%d\", &arr2[i]);\n    }\n    \n    int i = 0, j = 0, k = 0;\n    while (i < n1 && j < n2) {\n        if (arr1[i] <= arr2[j]) {\n            result[k++] = arr1[i++];\n        } else {\n            result[k++] = arr2[j++];\n        }\n    }\n    \n    while (i < n1) result[k++] = arr1[i++];\n    while (j < n2) result[k++] = arr2[j++];\n    \n    for (int i = 0; i < k; i++) {\n        printf(\"%d\", result[i]);\n        if (i < k - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(n + m)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Merge Two Sorted Lists - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Merge+Two+Sorted+Lists+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Merge Two Sorted Lists:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 24,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Delete First Occurrence of a Key",
      "description": "Problem: Delete the first node containing key k in a singly linked list.\n\nInput:\n- n elements\n- key k\n\nOutput:\n- Updated linked list."
    },
    "question2": {
      "name": "Remove Linked List Elements",
      "link": "https://leetcode.com/problems/remove-linked-list-elements/",
      "difficulty": "Easy"
    },
    "topics": [
      "Deletion",
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To delete an element from an array at a given position:\n\n1. Shift all elements after position 'pos' one step to the left\n2. This overwrites the element to be deleted\n3. Reduce the array size by 1\n\nKey Points:\n- Start shifting from the deletion position forward\n- No need to clear the last element (it's now outside array bounds)\n- Position is 1-based for input, but array uses 0-based indexing",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, pos;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    scanf(\"%d\", &pos);\n    \n    // Shift elements left\n    for (int i = pos - 1; i < n - 1; i++) {\n        arr[i] = arr[i + 1];\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 2) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Remove Linked List Elements - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Remove+Linked+List+Elements+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Remove Linked List Elements:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 25,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Detect Loop in Linked List (Floyd\u2019s Algorithm)",
      "description": "Problem: Detect if a singly linked list contains a cycle using slow and fast pointers.\n\nOutput:\n- YES if cycle exists\n- NO otherwise"
    },
    "question2": {
      "name": "Linked List Cycle",
      "link": "https://leetcode.com/problems/linked-list-cycle/",
      "difficulty": "Easy"
    },
    "topics": [
      "Cycle Detection",
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linked List solution for Detect Loop in Linked List (Floyd\u2019s Algorithm):\n\n1. Define node structure\n2. Traverse the list as needed\n3. Modify pointers carefully\n\nKey Points:\n- Always check for NULL pointers\n- Draw diagrams to visualize pointer changes\n- Free memory when deleting nodes",
          "code": "#include &lt;stdio.h&gt;\n\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    \n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Linked List Cycle - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Linked+List+Cycle+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Linked List Cycle:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 26,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Doubly Linked List Insertion and Traversal",
      "description": "Problem: Create a doubly linked list and insert n integers at the end. Print list forward and backward.\n\nOutput:\n- Forward traversal\n- Reverse traversal"
    },
    "question2": {
      "name": "Design Linked List",
      "link": "https://leetcode.com/problems/design-linked-list/",
      "difficulty": "Medium"
    },
    "topics": [
      "Doubly Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To insert an element at a specific position in an array:\n\n1. Shift all elements from position 'pos' to the end, one step to the right\n2. Insert the new element at the specified position\n3. The array size increases by 1\n\nKey Points:\n- Start shifting from the end to avoid overwriting values\n- Position is 1-based (user-friendly), but array indexing is 0-based\n- Ensure the array has enough space for the new element",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, pos, x;\n    int arr[101]; // Extra space for insertion\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    scanf(\"%d %d\", &pos, &x);\n    \n    // Shift elements right from end\n    for (int i = n; i >= pos; i--) {\n        arr[i] = arr[i - 1];\n    }\n    \n    arr[pos - 1] = x;\n    \n    for (int i = 0; i <= n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Design Linked List - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Design+Linked+List+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Design Linked List:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 27,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Find Intersection Point of Two Linked Lists",
      "description": "Problem: Given two linked lists, find the node where they intersect using length difference method.\n\nOutput:\n- Data of intersection node OR -1"
    },
    "question2": {
      "name": "Intersection of Two Linked Lists",
      "link": "https://leetcode.com/problems/intersection-of-two-linked-lists/",
      "difficulty": "Easy"
    },
    "topics": [
      "Linked List",
      "Intersection"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linked List solution for Find Intersection Point of Two Linked Lists:\n\n1. Define node structure\n2. Traverse the list as needed\n3. Modify pointers carefully\n\nKey Points:\n- Always check for NULL pointers\n- Draw diagrams to visualize pointer changes\n- Free memory when deleting nodes",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    \n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Intersection of Two Linked Lists - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Intersection+of+Two+Linked+Lists+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Intersection of Two Linked Lists:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 28,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Circular Linked List Creation and Traversal",
      "description": "Problem: Convert a singly linked list into a circular list and traverse exactly n nodes.\n\nOutput:\n- Circular traversal of n elements."
    },
    "question2": {
      "name": "Insert into a Sorted Circular Linked List",
      "link": "https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/",
      "difficulty": "Medium"
    },
    "topics": [
      "Circular Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linked List solution for Circular Linked List Creation and Traversal:\n\n1. Define node structure\n2. Traverse the list as needed\n3. Modify pointers carefully\n\nKey Points:\n- Always check for NULL pointers\n- Draw diagrams to visualize pointer changes\n- Free memory when deleting nodes",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    \n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Insert into a Sorted Circular Linked List - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Insert+into+a+Sorted+Circular+Linked+List+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Insert into a Sorted Circular Linked List:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 29,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Rotate Linked List Right by k Places",
      "description": "Problem: Rotate list right by k nodes using length and pointer adjustment.\n\nExample:\n1 2 3 4 5, k=2 \u2192 4 5 1 2 3"
    },
    "question2": {
      "name": "Rotate a Linked List",
      "link": "https://practice.geeksforgeeks.org/problems/rotate-a-linked-list/1",
      "difficulty": "Medium"
    },
    "topics": [
      "Rotation",
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linked List solution for Rotate Linked List Right by k Places:\n\n1. Define node structure\n2. Traverse the list as needed\n3. Modify pointers carefully\n\nKey Points:\n- Always check for NULL pointers\n- Draw diagrams to visualize pointer changes\n- Free memory when deleting nodes",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    \n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Rotate a Linked List - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Rotate+a+Linked+List+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Rotate a Linked List:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 30,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Polynomial Using Linked List",
      "description": "Problem: Store a polynomial using a linked list (coeff, power). Print in format: c1x^p1 + c2x^p2 ..."
    },
    "question2": {
      "name": "Add Two Numbers II",
      "link": "https://leetcode.com/problems/add-two-numbers-ii/",
      "difficulty": "Medium"
    },
    "topics": [
      "Polynomial LL",
      "Representation"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linked List solution for Polynomial Using Linked List:\n\n1. Define node structure\n2. Traverse the list as needed\n3. Modify pointers carefully\n\nKey Points:\n- Always check for NULL pointers\n- Draw diagrams to visualize pointer changes\n- Free memory when deleting nodes",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    \n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Add Two Numbers II - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Add+Two+Numbers+II+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Add Two Numbers II:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 31,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Implement Stack Using Array",
      "description": "Problem: Implement PUSH, POP, PEEK, DISPLAY using array of size 100.\nPOP and PEEK must print UNDERFLOW when stack is empty."
    },
    "question2": {
      "name": "Valid Parentheses",
      "link": "https://leetcode.com/problems/valid-parentheses/",
      "difficulty": "Easy"
    },
    "topics": [
      "Stack",
      "Array Implementation"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Stack-based solution for Implement Stack Using Array:\n\n1. Use LIFO (Last In First Out) principle\n2. Push elements onto stack\n3. Pop elements when needed\n\nKey Points:\n- Check for stack overflow/underflow\n- Stack useful for nested structures\n- Time complexity usually O(n)",
          "code": "#include <stdio.h>\n#define MAX 100\n\nint stack[MAX];\nint top = -1;\n\nvoid push(int x) {\n    if (top < MAX - 1) {\n        stack[++top] = x;\n    }\n}\n\nint pop() {\n    if (top >= 0) {\n        return stack[top--];\n    }\n    return -1;\n}\n\nint main() {\n    push(10);\n    push(20);\n    printf(\"%d\\n\", pop());\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Valid Parentheses - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Valid+Parentheses+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Valid Parentheses:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 32,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Implement Stack Using Linked List",
      "description": "Use LL with push (insert at head), pop (remove head), peek, display."
    },
    "question2": {
      "name": "Implement Stack Using Queues",
      "link": "https://leetcode.com/problems/implement-stack-using-queues/",
      "difficulty": "Easy"
    },
    "topics": [
      "Stack",
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linked List solution for Implement Stack Using Linked List:\n\n1. Define node structure\n2. Traverse the list as needed\n3. Modify pointers carefully\n\nKey Points:\n- Always check for NULL pointers\n- Draw diagrams to visualize pointer changes\n- Free memory when deleting nodes",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    \n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Implement Stack Using Queues - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Implement+Stack+Using+Queues+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Implement Stack Using Queues:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 33,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Infix to Postfix Conversion",
      "description": "Use stack for operators. Support +,-,*,/,^ and parentheses.\nExample:\nA+B*C \u2192 ABC*+"
    },
    "question2": {
      "name": "Basic Calculator II",
      "link": "https://leetcode.com/problems/basic-calculator-ii/",
      "difficulty": "Medium"
    },
    "topics": [
      "Stack",
      "Expression Parsing"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Infix to Postfix Conversion:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Basic Calculator II - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Basic+Calculator+II+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Basic Calculator II:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 34,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Evaluate Postfix Expression",
      "description": "Use stack to evaluate postfix expressions.\nExample:\n231*+9- \u2192 -4"
    },
    "question2": {
      "name": "Evaluate Reverse Polish Notation",
      "link": "https://leetcode.com/problems/evaluate-reverse-polish-notation/",
      "difficulty": "Medium"
    },
    "topics": [
      "Expression Evaluation"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Evaluate Postfix Expression:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Evaluate Reverse Polish Notation - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Evaluate+Reverse+Polish+Notation+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Evaluate Reverse Polish Notation:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 35,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Queue Using Array",
      "description": "Implement enqueue, dequeue, peek, display using array.\nUnderflow when empty."
    },
    "question2": {
      "name": "Number of Recent Calls",
      "link": "https://leetcode.com/problems/number-of-recent-calls/",
      "difficulty": "Easy"
    },
    "topics": [
      "Queue",
      "Array"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Queue-based solution for Queue Using Array:\n\n1. Use FIFO (First In First Out) principle\n2. Enqueue elements at rear\n3. Dequeue elements from front\n\nKey Points:\n- Check for queue full/empty\n- Useful for BFS and scheduling\n- Circular queue saves space",
          "code": "#include <stdio.h>\n#define MAX 100\n\nint queue[MAX];\nint front = 0, rear = 0;\n\nvoid enqueue(int x) {\n    if (rear < MAX) {\n        queue[rear++] = x;\n    }\n}\n\nint dequeue() {\n    if (front < rear) {\n        return queue[front++];\n    }\n    return -1;\n}\n\nint main() {\n    enqueue(10);\n    enqueue(20);\n    printf(\"%d\\n\", dequeue());\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Number of Recent Calls - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Number+of+Recent+Calls+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Number of Recent Calls:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 36,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Circular Queue Using Array",
      "description": "Use front, rear, size, array of fixed length. Use modulo for circular behavior."
    },
    "question2": {
      "name": "Design Circular Deque",
      "link": "https://leetcode.com/problems/design-circular-deque/",
      "difficulty": "Medium"
    },
    "topics": [
      "Circular Queue"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Queue-based solution for Circular Queue Using Array:\n\n1. Use FIFO (First In First Out) principle\n2. Enqueue elements at rear\n3. Dequeue elements from front\n\nKey Points:\n- Check for queue full/empty\n- Useful for BFS and scheduling\n- Circular queue saves space",
          "code": "#include <stdio.h>\n#define MAX 100\n\nint queue[MAX];\nint front = 0, rear = 0;\n\nvoid enqueue(int x) {\n    if (rear < MAX) {\n        queue[rear++] = x;\n    }\n}\n\nint dequeue() {\n    if (front < rear) {\n        return queue[front++];\n    }\n    return -1;\n}\n\nint main() {\n    enqueue(10);\n    enqueue(20);\n    printf(\"%d\\n\", dequeue());\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Design Circular Deque - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Design+Circular+Deque+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Design Circular Deque:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 37,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Double Ended Queue (Deque)",
      "description": "Implement insertFront, insertRear, deleteFront, deleteRear using array."
    },
    "question2": {
      "name": "Min Stack",
      "link": "https://leetcode.com/problems/min-stack/",
      "difficulty": "Medium"
    },
    "topics": [
      "Deque",
      "Double Ended Queue"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Queue-based solution for Double Ended Queue (Deque):\n\n1. Use FIFO (First In First Out) principle\n2. Enqueue elements at rear\n3. Dequeue elements from front\n\nKey Points:\n- Check for queue full/empty\n- Useful for BFS and scheduling\n- Circular queue saves space",
          "code": "#include <stdio.h>\n#define MAX 100\n\nint queue[MAX];\nint front = 0, rear = 0;\n\nvoid enqueue(int x) {\n    if (rear < MAX) {\n        queue[rear++] = x;\n    }\n}\n\nint dequeue() {\n    if (front < rear) {\n        return queue[front++];\n    }\n    return -1;\n}\n\nint main() {\n    enqueue(10);\n    enqueue(20);\n    printf(\"%d\\n\", dequeue());\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Min Stack - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Min+Stack+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Min Stack:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 38,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Priority Queue Using Array",
      "description": "Each insertion keeps array sorted by priority.\nDELETE removes highest priority element."
    },
    "question2": {
      "name": "Kth Largest Element in a Stream",
      "link": "https://leetcode.com/problems/kth-largest-element-in-a-stream/",
      "difficulty": "Easy"
    },
    "topics": [
      "Priority Queue"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Queue-based solution for Priority Queue Using Array:\n\n1. Use FIFO (First In First Out) principle\n2. Enqueue elements at rear\n3. Dequeue elements from front\n\nKey Points:\n- Check for queue full/empty\n- Useful for BFS and scheduling\n- Circular queue saves space",
          "code": "#include <stdio.h>\n#define MAX 100\n\nint queue[MAX];\nint front = 0, rear = 0;\n\nvoid enqueue(int x) {\n    if (rear < MAX) {\n        queue[rear++] = x;\n    }\n}\n\nint dequeue() {\n    if (front < rear) {\n        return queue[front++];\n    }\n    return -1;\n}\n\nint main() {\n    enqueue(10);\n    enqueue(20);\n    printf(\"%d\\n\", dequeue());\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Kth Largest Element in a Stream - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Kth+Largest+Element+in+a+Stream+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Kth Largest Element in a Stream:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 39,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Min Heap Implementation",
      "description": "Insert elements into Min Heap and print heap array."
    },
    "question2": {
      "name": "Top K Frequent Elements",
      "link": "https://leetcode.com/problems/top-k-frequent-elements/",
      "difficulty": "Medium"
    },
    "topics": [
      "Heap",
      "Priority Queue"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Min Heap Implementation:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Top K Frequent Elements - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Top+K+Frequent+Elements+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Top K Frequent Elements:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 40,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Heap Sort Using Max-Heap",
      "description": "Build Max-Heap, then repeatedly delete max to sort in ascending order."
    },
    "question2": {
      "name": "Daily Temperatures",
      "link": "https://leetcode.com/problems/daily-temperatures/",
      "difficulty": "Medium"
    },
    "topics": [
      "Heap Sort",
      "Sorting"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Sorting algorithm for Heap Sort Using Max-Heap:\n\n1. Compare and swap elements\n2. Repeat until array is sorted\n3. Optimize based on algorithm choice\n\nKey Points:\n- Different algorithms for different use cases\n- Bubble/Selection: O(n\u00b2), simple\n- Merge/Quick: O(n log n), efficient",
          "code": "#include &lt;stdio.h&gt;\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int n = 5;\n    bubbleSort(arr, n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Daily Temperatures - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Daily+Temperatures+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Daily Temperatures:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 41,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Queue Using Linked List",
      "description": "Problem: Implement a queue using singly linked list. Support ENQUEUE, DEQUEUE, PEEK, DISPLAY.\n\nInput:\n- q operations\n\nOutput:\n- DEQUEUE prints removed element or UNDERFLOW\n- PEEK prints front element or UNDERFLOW\n- DISPLAY prints queue elements"
    },
    "question2": {
      "name": "Task Scheduler",
      "link": "https://leetcode.com/problems/task-scheduler/",
      "difficulty": "Medium"
    },
    "topics": [
      "Queue",
      "Linked List Implementation"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linked List solution for Queue Using Linked List:\n\n1. Define node structure\n2. Traverse the list as needed\n3. Modify pointers carefully\n\nKey Points:\n- Always check for NULL pointers\n- Draw diagrams to visualize pointer changes\n- Free memory when deleting nodes",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    \n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Task Scheduler - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Task+Scheduler+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Task Scheduler:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 42,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Reverse a Queue Using Stack",
      "description": "Problem: Reverse a queue using stack operations only.\n\nInput:\n- n\n- n queue elements\n\nOutput:\n- Reversed queue elements"
    },
    "question2": {
      "name": "Find Median from Data Stream",
      "link": "https://leetcode.com/problems/find-median-from-data-stream/",
      "difficulty": "Hard"
    },
    "topics": [
      "Queue",
      "Stack",
      "Reversal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Reverse an array using the two-pointer technique:\n\n1. Use two pointers: one at start (left) and one at end (right)\n2. Swap elements at left and right pointers\n3. Move left pointer forward and right pointer backward\n4. Continue until left >= right\n\nKey Points:\n- In-place reversal (no extra array needed)\n- Efficient with O(n/2) swaps\n- Works for arrays of any size",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Two-pointer reversal\n    int left = 0, right = n - 1;\n    while (left < right) {\n        int temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Find Median from Data Stream - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Find+Median+from+Data+Stream+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Find Median from Data Stream:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 43,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Binary Tree Construction (Level Order)",
      "description": "Problem: Build a binary tree from level-order input. -1 represents NULL.\n\nInput:\n- n values including -1\n\nOutput:\n- Inorder traversal of the tree"
    },
    "question2": {
      "name": "Binary Tree Inorder Traversal",
      "link": "https://leetcode.com/problems/binary-tree-inorder-traversal/",
      "difficulty": "Easy"
    },
    "topics": [
      "Binary Tree",
      "Construction"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for Binary Tree Construction (Level Order):\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Binary Tree Inorder Traversal - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Binary+Tree+Inorder+Traversal+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Binary Tree Inorder Traversal:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 44,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Binary Tree Traversals",
      "description": "Problem: Build a binary tree and print:\n- Preorder\n- Inorder\n- Postorder\n\nUse recursive methods."
    },
    "question2": {
      "name": "Binary Tree Preorder Traversal",
      "link": "https://leetcode.com/problems/binary-tree-preorder-traversal/",
      "difficulty": "Easy"
    },
    "topics": [
      "Tree Traversal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for Binary Tree Traversals:\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Binary Tree Preorder Traversal - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Binary+Tree+Preorder+Traversal+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Binary Tree Preorder Traversal:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 45,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Height of a Binary Tree",
      "description": "Problem: Compute height of binary tree using recursion.\n\nHeight = longest path from root to leaf."
    },
    "question2": {
      "name": "Maximum Depth of Binary Tree",
      "link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
      "difficulty": "Easy"
    },
    "topics": [
      "Binary Tree",
      "Recursion"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for Height of a Binary Tree:\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Maximum Depth of Binary Tree - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Maximum+Depth+of+Binary+Tree+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Maximum Depth of Binary Tree:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 46,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Count Leaf Nodes",
      "description": "Problem: Count number of leaf nodes in a binary tree.\n\nLeaf node: node with no children."
    },
    "question2": {
      "name": "Diameter of Binary Tree",
      "link": "https://leetcode.com/problems/diameter-of-binary-tree/",
      "difficulty": "Easy"
    },
    "topics": [
      "Binary Tree",
      "Leaf Count"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linked List solution for Count Leaf Nodes:\n\n1. Define node structure\n2. Traverse the list as needed\n3. Modify pointers carefully\n\nKey Points:\n- Always check for NULL pointers\n- Draw diagrams to visualize pointer changes\n- Free memory when deleting nodes",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    \n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Diameter of Binary Tree - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Diameter+of+Binary+Tree+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Diameter of Binary Tree:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 47,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Count Leaf Nodes in Binary Tree",
      "description": "Problem: A binary tree is balanced if height difference of left and right subtree \u2264 1 for every node. Check recursively."
    },
    "question2": {
      "name": "Balanced Binary Tree",
      "link": "https://leetcode.com/problems/balanced-binary-tree/",
      "difficulty": "Easy"
    },
    "topics": [
      "Balanced Tree",
      "Binary Tree"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linked List solution for Count Leaf Nodes in Binary Tree:\n\n1. Define node structure\n2. Traverse the list as needed\n3. Modify pointers carefully\n\nKey Points:\n- Always check for NULL pointers\n- Draw diagrams to visualize pointer changes\n- Free memory when deleting nodes",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    \n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Balanced Binary Tree - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Balanced+Binary+Tree+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Balanced Binary Tree:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 48,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "BST Insertion & Inorder Traversal",
      "description": "Problem: Create a Binary Search Tree by inserting n integers. Then print inorder traversal (which should be sorted)."
    },
    "question2": {
      "name": "Validate Binary Search Tree",
      "link": "https://leetcode.com/problems/validate-binary-search-tree/",
      "difficulty": "Medium"
    },
    "topics": [
      "BST",
      "Insertion"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To insert an element at a specific position in an array:\n\n1. Shift all elements from position 'pos' to the end, one step to the right\n2. Insert the new element at the specified position\n3. The array size increases by 1\n\nKey Points:\n- Start shifting from the end to avoid overwriting values\n- Position is 1-based (user-friendly), but array indexing is 0-based\n- Ensure the array has enough space for the new element",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, pos, x;\n    int arr[101]; // Extra space for insertion\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    scanf(\"%d %d\", &pos, &x);\n    \n    // Shift elements right from end\n    for (int i = n; i >= pos; i--) {\n        arr[i] = arr[i - 1];\n    }\n    \n    arr[pos - 1] = x;\n    \n    for (int i = 0; i <= n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Validate Binary Search Tree - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Validate+Binary+Search+Tree+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Validate Binary Search Tree:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 49,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Search in BST",
      "description": "Problem: Insert elements in BST, then search for key k.\nPrint FOUND or NOT FOUND."
    },
    "question2": {
      "name": "Search in a Binary Search Tree",
      "link": "https://leetcode.com/problems/search-in-a-binary-search-tree/",
      "difficulty": "Easy"
    },
    "topics": [
      "BST Search"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for Search in BST:\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Search in a Binary Search Tree - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Search+in+a+Binary+Search+Tree+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Search in a Binary Search Tree:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 50,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Delete Node from BST",
      "description": "Problem: Delete a key from BST handling three cases:\n1. Leaf node\n2. Node with one child\n3. Node with two children (replace with inorder successor)."
    },
    "question2": {
      "name": "Delete Node in a BST",
      "link": "https://leetcode.com/problems/delete-node-in-a-bst/",
      "difficulty": "Medium"
    },
    "topics": [
      "BST Deletion"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To delete an element from an array at a given position:\n\n1. Shift all elements after position 'pos' one step to the left\n2. This overwrites the element to be deleted\n3. Reduce the array size by 1\n\nKey Points:\n- Start shifting from the deletion position forward\n- No need to clear the last element (it's now outside array bounds)\n- Position is 1-based for input, but array uses 0-based indexing",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, pos;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    scanf(\"%d\", &pos);\n    \n    // Shift elements left\n    for (int i = pos - 1; i < n - 1; i++) {\n        arr[i] = arr[i + 1];\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 2) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Delete Node in a BST - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Delete+Node+in+a+BST+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Delete Node in a BST:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 51,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Lowest Common Ancestor in BST",
      "description": "Problem: Given BST and two keys, find LCA using BST properties."
    },
    "question2": {
      "name": "Lowest Common Ancestor of a BST",
      "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
      "difficulty": "Easy"
    },
    "topics": [
      "BST",
      "LCA"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for Lowest Common Ancestor in BST:\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Lowest Common Ancestor of a BST - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Lowest+Common+Ancestor+of+a+BST+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Lowest Common Ancestor of a BST:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 52,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "LCA in Binary Tree",
      "description": "Problem: Find Lowest Common Ancestor in general binary tree using recursion."
    },
    "question2": {
      "name": "Lowest Common Ancestor of a Binary Tree",
      "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
      "difficulty": "Medium"
    },
    "topics": [
      "Binary Tree",
      "LCA"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for LCA in Binary Tree:\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Lowest Common Ancestor of a Binary Tree - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Lowest+Common+Ancestor+of+a+Binary+Tree+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Lowest Common Ancestor of a Binary Tree:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 53,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Print Binary Tree Vertical Order",
      "description": "Problem: Print level-order traversal using a queue."
    },
    "question2": {
      "name": "Binary Tree Level Order Traversal",
      "link": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
      "difficulty": "Medium"
    },
    "topics": [
      "Tree Traversal",
      "BFS"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for Print Binary Tree Vertical Order:\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Binary Tree Level Order Traversal - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Binary+Tree+Level+Order+Traversal+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Binary Tree Level Order Traversal:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 54,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Zigzag Traversal",
      "description": "Problem: Print Zigzag order of binary tree using queue + reversing alternate levels."
    },
    "question2": {
      "name": "Binary Tree Zigzag Level Order Traversal",
      "link": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/",
      "difficulty": "Medium"
    },
    "topics": [
      "Tree Traversal",
      "Zigzag"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Zigzag Traversal:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Binary Tree Zigzag Level Order Traversal - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Binary+Tree+Zigzag+Level+Order+Traversal+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Binary Tree Zigzag Level Order Traversal:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 55,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Right View of Binary Tree",
      "description": "Problem: Print the rightmost node at every level using BFS or DFS."
    },
    "question2": {
      "name": "Binary Tree Right Side View",
      "link": "https://leetcode.com/problems/binary-tree-right-side-view/",
      "difficulty": "Medium"
    },
    "topics": [
      "Tree View Problems"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for Right View of Binary Tree:\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Binary Tree Right Side View - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Binary+Tree+Right+Side+View+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Binary Tree Right Side View:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 56,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Symmetric Binary Tree Check",
      "description": "Problem: Check if a tree is mirror of itself. Use recursive mirror function."
    },
    "question2": {
      "name": "Symmetric Tree",
      "link": "https://leetcode.com/problems/symmetric-tree/",
      "difficulty": "Easy"
    },
    "topics": [
      "Symmetry",
      "Binary Tree"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for Symmetric Binary Tree Check:\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Symmetric Tree - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Symmetric+Tree+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Symmetric Tree:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 57,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Mirror a Binary Tree",
      "description": "Problem: Flatten a binary tree into a linked list in preorder traversal using right pointers only."
    },
    "question2": {
      "name": "Flatten Binary Tree to Linked List",
      "link": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/",
      "difficulty": "Medium"
    },
    "topics": [
      "Binary Tree",
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for Mirror a Binary Tree:\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Flatten Binary Tree to Linked List - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Flatten+Binary+Tree+to+Linked+List+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Flatten Binary Tree to Linked List:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 58,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Build Tree from Inorder & Preorder",
      "description": "Problem: Construct binary tree using preorder and inorder arrays recursively."
    },
    "question2": {
      "name": "Construct Binary Tree from Preorder and Inorder Traversal",
      "link": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
      "difficulty": "Medium"
    },
    "topics": [
      "Tree Construction"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for Build Tree from Inorder & Preorder:\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Construct Binary Tree from Preorder and Inorder Traversal - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Construct+Binary+Tree+from+Preorder+and+Inorder+Traversal+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Construct Binary Tree from Preorder and Inorder Traversal:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 59,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Build Tree from Inorder & Postorder",
      "description": "Problem: Construct binary tree using postorder and inorder arrays."
    },
    "question2": {
      "name": "Construct Binary Tree from Inorder and Postorder Traversal",
      "link": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",
      "difficulty": "Medium"
    },
    "topics": [
      "Binary Tree",
      "Construction"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Tree-based solution for Build Tree from Inorder & Postorder:\n\n1. Define tree node structure\n2. Implement tree traversal (inorder/preorder/postorder)\n3. Process nodes as needed\n\nKey Points:\n- Recursion natural for trees\n- Three main traversals: inorder, preorder, postorder\n- Binary Search Tree maintains order property",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\nvoid inorder(struct Node* root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->data);\n        inorder(root->right);\n    }\n}\n\nint main() {\n    struct Node* root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    inorder(root);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Construct Binary Tree from Inorder and Postorder Traversal - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Construct+Binary+Tree+from+Inorder+and+Postorder+Traversal+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Construct Binary Tree from Inorder and Postorder Traversal:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 60,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Validate Min-Heap",
      "description": "Problem: Given array representation of heap, check if Min Heap property holds: parent <= children."
    },
    "question2": {
      "name": "Binary Tree Cameras",
      "link": "https://leetcode.com/problems/binary-tree-cameras/",
      "difficulty": "Hard"
    },
    "topics": [
      "Heap",
      "Tree"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Validate Min-Heap:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Binary Tree Cameras - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Binary+Tree+Cameras+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Binary Tree Cameras:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 61,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Graph Representation Using Adjacency Matrix",
      "description": "Problem: Build a graph with n vertices and m edges using adjacency matrix representation.\nThe graph may be directed or undirected.\n\nInput:\n- n (vertices)\n- m (edges)\n- m pairs (u, v)\n\nOutput:\n- n x n adjacency matrix"
    },
    "question2": {
      "name": "Number of Provinces",
      "link": "https://leetcode.com/problems/number-of-provinces/",
      "difficulty": "Medium"
    },
    "topics": [
      "Graph Basics",
      "Adjacency Matrix"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Graph Representation Using Adjacency Matrix:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Number of Provinces - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Number+of+Provinces+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Number of Provinces:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 62,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Graph Representation Using Adjacency List",
      "description": "Problem: Build a graph with adjacency list representation. Use linked lists or dynamic arrays.\n\nInput:\n- n (vertices)\n- m (edges)\n- edges (u, v)\n\nOutput:\n- List of adjacency lists for each vertex"
    },
    "question2": {
      "name": "Keys and Rooms",
      "link": "https://leetcode.com/problems/keys-and-rooms/",
      "difficulty": "Medium"
    },
    "topics": [
      "Graph Representation",
      "Adjacency List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Graph Representation Using Adjacency List:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Keys and Rooms - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Keys+and+Rooms+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Keys and Rooms:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 63,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Depth First Search (DFS)",
      "description": "Problem: Perform DFS starting from a given source vertex using recursion.\n\nInput:\n- n\n- adjacency list\n- starting vertex s\n\nOutput:\n- DFS traversal order"
    },
    "question2": {
      "name": "Flood Fill",
      "link": "https://leetcode.com/problems/flood-fill/",
      "difficulty": "Easy"
    },
    "topics": [
      "DFS",
      "Graph Traversal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Depth First Search (DFS):\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Flood Fill - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Flood+Fill+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Flood Fill:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 64,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Breadth First Search (BFS)",
      "description": "Problem: Perform BFS from a given source using queue.\n\nInput:\n- n\n- adjacency list\n- source s\n\nOutput:\n- BFS traversal order"
    },
    "question2": {
      "name": "Rotting Oranges",
      "link": "https://leetcode.com/problems/rotting-oranges/",
      "difficulty": "Medium"
    },
    "topics": [
      "BFS",
      "Graph Traversal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Breadth First Search (BFS):\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Rotting Oranges - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Rotting+Oranges+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Rotting Oranges:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 65,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Cycle Detection in Undirected Graph (DFS)",
      "description": "Problem: Using DFS and parent tracking, detect if undirected graph has a cycle.\n\nOutput:\n- YES or NO"
    },
    "question2": {
      "name": "Graph Cycle Detection",
      "link": "https://practice.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1",
      "difficulty": "Medium"
    },
    "topics": [
      "Cycle Detection",
      "DFS"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Cycle Detection in Undirected Graph (DFS):\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Graph Cycle Detection - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Graph+Cycle+Detection+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Graph Cycle Detection:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 66,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Cycle Detection in Directed Graph",
      "description": "Problem: Detect cycle in directed graph using DFS and recursion stack.\n\nOutput:\n- YES if cycle exists"
    },
    "question2": {
      "name": "Course Schedule",
      "link": "https://leetcode.com/problems/course-schedule/",
      "difficulty": "Medium"
    },
    "topics": [
      "Directed Graph",
      "Cycle Detection"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Cycle Detection in Directed Graph:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Course Schedule - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Course+Schedule+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Course Schedule:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 67,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Topological Sort (DFS)",
      "description": "Problem: Print topological ordering of a Directed Acyclic Graph (DAG) using DFS."
    },
    "question2": {
      "name": "Course Schedule II",
      "link": "https://leetcode.com/problems/course-schedule-ii/",
      "difficulty": "Medium"
    },
    "topics": [
      "Topological Sort",
      "DFS"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Sorting algorithm for Topological Sort (DFS):\n\n1. Compare and swap elements\n2. Repeat until array is sorted\n3. Optimize based on algorithm choice\n\nKey Points:\n- Different algorithms for different use cases\n- Bubble/Selection: O(n\u00b2), simple\n- Merge/Quick: O(n log n), efficient",
          "code": "#include &lt;stdio.h&gt;\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int n = 5;\n    bubbleSort(arr, n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Course Schedule II - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Course+Schedule+II+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Course Schedule II:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 68,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Topological Sort (Kahn\u2019s BFS Algorithm)",
      "description": "Problem: Implement topological sorting using in-degree array and queue (Kahn\u2019s Algorithm)."
    },
    "question2": {
      "name": "Alien Dictionary",
      "link": "https://practice.geeksforgeeks.org/problems/alien-dictionary/1",
      "difficulty": "Hard"
    },
    "topics": [
      "Topological Sort",
      "Kahn's Algorithm"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Sorting algorithm for Topological Sort (Kahn\u2019s BFS Algorithm):\n\n1. Compare and swap elements\n2. Repeat until array is sorted\n3. Optimize based on algorithm choice\n\nKey Points:\n- Different algorithms for different use cases\n- Bubble/Selection: O(n\u00b2), simple\n- Merge/Quick: O(n log n), efficient",
          "code": "#include &lt;stdio.h&gt;\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int n = 5;\n    bubbleSort(arr, n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Alien Dictionary - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Alien+Dictionary+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Alien Dictionary:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 69,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Dijkstra\u2019s Algorithm (Shortest Path)",
      "description": "Problem: Given weighted graph with non-negative edges, compute shortest path from source using priority queue."
    },
    "question2": {
      "name": "Network Delay Time",
      "link": "https://leetcode.com/problems/network-delay-time/",
      "difficulty": "Medium"
    },
    "topics": [
      "Dijkstra",
      "Shortest Path"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Dijkstra\u2019s Algorithm (Shortest Path):\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Network Delay Time - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Network+Delay+Time+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Network Delay Time:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 70,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Bellman-Ford Algorithm",
      "description": "Problem: Compute shortest path from source and detect negative weight cycles using Bellman-Ford.\n\nInput:\n- n vertices\n- m edges (u,v,w)\n\nOutput:\n- Shortest distances OR NEGATIVE CYCLE"
    },
    "question2": {
      "name": "Cheapest Flights Within K Stops",
      "link": "https://leetcode.com/problems/cheapest-flights-within-k-stops/",
      "difficulty": "Medium"
    },
    "topics": [
      "Bellman-Ford",
      "Shortest Path"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Bellman-Ford Algorithm:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Cheapest Flights Within K Stops - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Cheapest+Flights+Within+K+Stops+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Cheapest Flights Within K Stops:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 71,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Prim\u2019s Algorithm (MST)",
      "description": "Problem: Compute Minimum Spanning Tree using Prim\u2019s algorithm and priority queue.\n\nOutput:\n- Weighted sum of MST edges."
    },
    "question2": {
      "name": "Min Cost to Connect All Points",
      "link": "https://leetcode.com/problems/min-cost-to-connect-all-points/",
      "difficulty": "Medium"
    },
    "topics": [
      "MST",
      "Prim's Algorithm"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Prim\u2019s Algorithm (MST):\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Min Cost to Connect All Points - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Min+Cost+to+Connect+All+Points+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Min Cost to Connect All Points:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 72,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Kruskal\u2019s Algorithm (MST)",
      "description": "Problem: Build MST using edge list + sorting + DSU (union-find)."
    },
    "question2": {
      "name": "Optimize Water Distribution in a Village",
      "link": "https://leetcode.com/problems/optimize-water-distribution-in-a-village/",
      "difficulty": "Hard"
    },
    "topics": [
      "MST",
      "Union-Find"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Kruskal\u2019s Algorithm (MST):\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Optimize Water Distribution in a Village - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Optimize+Water+Distribution+in+a+Village+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Optimize Water Distribution in a Village:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 73,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Disjoint Set Union (Union-Find)",
      "description": "Problem: Implement DSU with path compression and union by rank. Perform q union/find operations."
    },
    "question2": {
      "name": "Redundant Connection",
      "link": "https://leetcode.com/problems/redundant-connection/",
      "difficulty": "Medium"
    },
    "topics": [
      "DSU",
      "Union-Find"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Disjoint Set Union (Union-Find):\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Redundant Connection - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Redundant+Connection+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Redundant Connection:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 74,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Implement Graph using Adjacency Matrix",
      "description": "Problem: Use DFS or Union-Find to count connected components in graph."
    },
    "question2": {
      "name": "Number of Connected Components in an Undirected Graph",
      "link": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
      "difficulty": "Medium"
    },
    "topics": [
      "Connected Components",
      "DFS"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Implement Graph using Adjacency Matrix:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Number of Connected Components in an Undirected Graph - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Number+of+Connected+Components+in+an+Undirected+Graph+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Number of Connected Components in an Undirected Graph:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 75,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Bipartite Graph Check",
      "description": "Problem: Check whether graph is bipartite using BFS/DFS two-coloring method."
    },
    "question2": {
      "name": "Is Graph Bipartite?",
      "link": "https://leetcode.com/problems/is-graph-bipartite/",
      "difficulty": "Medium"
    },
    "topics": [
      "Bipartite Graph",
      "Graph Coloring"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Bipartite Graph Check:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Is Graph Bipartite? - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Is+Graph+Bipartite?+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Is Graph Bipartite?:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 76,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Clone an Undirected Graph",
      "description": "Problem: Clone a graph using DFS or BFS and hash map."
    },
    "question2": {
      "name": "Clone Graph",
      "link": "https://leetcode.com/problems/clone-graph/",
      "difficulty": "Medium"
    },
    "topics": [
      "Graph Cloning",
      "Hash Map"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Clone an Undirected Graph:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Clone Graph - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Clone+Graph+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Clone Graph:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 77,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Detect Bridges in Graph (Tarjan)",
      "description": "Problem: Use DFS and time-in/time-out arrays to find bridges in undirected graph."
    },
    "question2": {
      "name": "Critical Connections in a Network",
      "link": "https://leetcode.com/problems/critical-connections-in-a-network/",
      "difficulty": "Hard"
    },
    "topics": [
      "Bridges",
      "Tarjan Algorithm"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Detect Bridges in Graph (Tarjan):\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Critical Connections in a Network - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Critical+Connections+in+a+Network+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Critical Connections in a Network:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 78,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Detect Articulation Points",
      "description": "Problem: Use Tarjan\u2019s algorithm to find articulation points using DFS, discovery time, and low time."
    },
    "question2": {
      "name": "Articulation Points (GFG)",
      "link": "https://practice.geeksforgeeks.org/problems/articulation-point-1/1",
      "difficulty": "Hard"
    },
    "topics": [
      "Articulation Points",
      "DFS"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Detect Articulation Points:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Articulation Points (GFG) - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Articulation+Points+(GFG)+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Articulation Points (GFG):\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 79,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Kosaraju\u2019s Algorithm (SCC)",
      "description": "Problem: Print strongly connected components using DFS + reverse graph."
    },
    "question2": {
      "name": "Strongly Connected Components",
      "link": "https://practice.geeksforgeeks.org/problems/strongly-connected-components-kosarajus-algo/1",
      "difficulty": "Medium"
    },
    "topics": [
      "SCC",
      "Kosaraju"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Kosaraju\u2019s Algorithm (SCC):\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Strongly Connected Components - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Strongly+Connected+Components+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Strongly Connected Components:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 80,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Floyd-Warshall Algorithm",
      "description": "Problem: Compute all-pairs shortest paths using DP-based Floyd-Warshall algorithm."
    },
    "question2": {
      "name": "Find the City With the Smallest Number of Neighbors",
      "link": "https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/",
      "difficulty": "Medium"
    },
    "topics": [
      "All-Pairs Shortest Path",
      "DP"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Floyd-Warshall Algorithm:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Find the City With the Smallest Number of Neighbors - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Find+the+City+With+the+Smallest+Number+of+Neighbors+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Find the City With the Smallest Number of Neighbors:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 81,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Implement Bubble Sort",
      "description": "Problem: Implement binary search to find index of key k in sorted array.\nPrint FOUND at index or NOT FOUND.\n\nInput:\n- n\n- sorted array\n- key k\n\nOutput:\n- FOUND at index i OR NOT FOUND"
    },
    "question2": {
      "name": "Binary Search",
      "link": "https://leetcode.com/problems/binary-search/",
      "difficulty": "Easy"
    },
    "topics": [
      "Binary Search",
      "Searching"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Sorting algorithm for Implement Bubble Sort:\n\n1. Compare and swap elements\n2. Repeat until array is sorted\n3. Optimize based on algorithm choice\n\nKey Points:\n- Different algorithms for different use cases\n- Bubble/Selection: O(n\u00b2), simple\n- Merge/Quick: O(n log n), efficient",
          "code": "#include &lt;stdio.h&gt;\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int n = 5;\n    bubbleSort(arr, n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Binary Search - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Binary+Search+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Binary Search:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 82,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Upper Bound & Lower Bound Implementation",
      "description": "Problem: Implement functions lowerBound(arr, x) and upperBound(arr, x).\nReturn index of first >= x and first > x.\nUseful in searching and frequency problems."
    },
    "question2": {
      "name": "Search Insert Position",
      "link": "https://leetcode.com/problems/search-insert-position/",
      "difficulty": "Easy"
    },
    "topics": [
      "Binary Search",
      "Bounds"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Upper Bound & Lower Bound Implementation:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Search Insert Position - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Search+Insert+Position+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Search Insert Position:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 83,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Implement Selection Sort",
      "description": "Problem: Given rotated sorted array, search key using modified binary search.\nExample:\n4 5 6 7 0 1 2, key=0 => index 4"
    },
    "question2": {
      "name": "Search in Rotated Sorted Array",
      "link": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
      "difficulty": "Medium"
    },
    "topics": [
      "Binary Search",
      "Rotation"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Sorting algorithm for Implement Selection Sort:\n\n1. Compare and swap elements\n2. Repeat until array is sorted\n3. Optimize based on algorithm choice\n\nKey Points:\n- Different algorithms for different use cases\n- Bubble/Selection: O(n\u00b2), simple\n- Merge/Quick: O(n log n), efficient",
          "code": "#include &lt;stdio.h&gt;\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int n = 5;\n    bubbleSort(arr, n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Search in Rotated Sorted Array - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Search+in+Rotated+Sorted+Array+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Search in Rotated Sorted Array:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 84,
    "unit": "Unit V: Hash Table & Graph",
    "question1": {
      "title": "Implement Insertion Sort",
      "description": "Problem: A peak element is greater than its neighbors. Use binary search on slopes to find any peak.\nReturn index."
    },
    "question2": {
      "name": "Find Peak Element",
      "link": "https://leetcode.com/problems/find-peak-element/",
      "difficulty": "Medium"
    },
    "topics": [
      "Binary Search on Answer"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To insert an element at a specific position in an array:\n\n1. Shift all elements from position 'pos' to the end, one step to the right\n2. Insert the new element at the specified position\n3. The array size increases by 1\n\nKey Points:\n- Start shifting from the end to avoid overwriting values\n- Position is 1-based (user-friendly), but array indexing is 0-based\n- Ensure the array has enough space for the new element",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, pos, x;\n    int arr[101]; // Extra space for insertion\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    scanf(\"%d %d\", &pos, &x);\n    \n    // Shift elements right from end\n    for (int i = n; i >= pos; i--) {\n        arr[i] = arr[i - 1];\n    }\n    \n    arr[pos - 1] = x;\n    \n    for (int i = 0; i <= n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Find Peak Element - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Find+Peak+Element+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Find Peak Element:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 85,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Implement Merge Sort",
      "description": "Problem: Use binary search to find the minimum element in a rotated sorted array."
    },
    "question2": {
      "name": "Find Minimum in Rotated Sorted Array",
      "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
      "difficulty": "Medium"
    },
    "topics": [
      "Binary Search",
      "Rotation"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Sorting algorithm for Implement Merge Sort:\n\n1. Compare and swap elements\n2. Repeat until array is sorted\n3. Optimize based on algorithm choice\n\nKey Points:\n- Different algorithms for different use cases\n- Bubble/Selection: O(n\u00b2), simple\n- Merge/Quick: O(n log n), efficient",
          "code": "#include &lt;stdio.h&gt;\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int n = 5;\n    bubbleSort(arr, n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Find Minimum in Rotated Sorted Array - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Find+Minimum+in+Rotated+Sorted+Array+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Find Minimum in Rotated Sorted Array:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 86,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Square Root using Binary Search",
      "description": "Problem: Given non-negative integer n, compute floor(sqrt(n)) using binary search.\nExample: n=10 \u2192 3"
    },
    "question2": {
      "name": "Sqrt(x)",
      "link": "https://leetcode.com/problems/sqrtx/",
      "difficulty": "Easy"
    },
    "topics": [
      "Binary Search",
      "Math"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Square Root using Binary Search:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Sqrt(x) - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Sqrt(x)+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Sqrt(x):\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 87,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Implement Binary Search Iterative",
      "description": "Problem: Find minimum eating speed K such that Koko can finish all piles in H hours.\nBinary search on answer."
    },
    "question2": {
      "name": "Koko Eating Bananas",
      "link": "https://leetcode.com/problems/koko-eating-bananas/",
      "difficulty": "Medium"
    },
    "topics": [
      "Binary Search on Answer"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Implement Binary Search Iterative:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Koko Eating Bananas - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Koko+Eating+Bananas+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Koko Eating Bananas:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 88,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Aggressive Cows Problem",
      "description": "Problem: Given stalls positions, place cows such that minimum distance between any two is maximized.\nBinary search on distance."
    },
    "question2": {
      "name": "Magnetic Force Between Two Balls",
      "link": "https://leetcode.com/problems/magnetic-force-between-two-balls/",
      "difficulty": "Medium"
    },
    "topics": [
      "Binary Search",
      "Distance Optimization"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Aggressive Cows Problem:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Magnetic Force Between Two Balls - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Magnetic+Force+Between+Two+Balls+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Magnetic Force Between Two Balls:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 89,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Allocate Minimum Pages",
      "description": "Problem: Split array among students such that maximum pages assigned is minimized.\nBinary search on answer."
    },
    "question2": {
      "name": "Capacity To Ship Packages Within D Days",
      "link": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/",
      "difficulty": "Medium"
    },
    "topics": [
      "Binary Search",
      "Load Balancing"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Allocate Minimum Pages:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Capacity To Ship Packages Within D Days - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Capacity+To+Ship+Packages+Within+D+Days+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Capacity To Ship Packages Within D Days:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 90,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Painter Partition Problem",
      "description": "Problem: Given boards and painters, minimize maximum time taken by any painter.\nBinary search on max workload."
    },
    "question2": {
      "name": "Split Array Largest Sum",
      "link": "https://leetcode.com/problems/split-array-largest-sum/",
      "difficulty": "Hard"
    },
    "topics": [
      "Binary Search on Answer"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Painter Partition Problem:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Split Array Largest Sum - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Split+Array+Largest+Sum+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Split Array Largest Sum:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 91,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Merge Sort Implementation",
      "description": "Problem: Implement merge sort (divide, sort halves, merge).\nPrint sorted array."
    },
    "question2": {
      "name": "Sort Colors",
      "link": "https://leetcode.com/problems/sort-colors/",
      "difficulty": "Medium"
    },
    "topics": [
      "Sorting",
      "Merge Sort"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Sorting algorithm for Merge Sort Implementation:\n\n1. Compare and swap elements\n2. Repeat until array is sorted\n3. Optimize based on algorithm choice\n\nKey Points:\n- Different algorithms for different use cases\n- Bubble/Selection: O(n\u00b2), simple\n- Merge/Quick: O(n log n), efficient",
          "code": "#include &lt;stdio.h&gt;\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int n = 5;\n    bubbleSort(arr, n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Sort Colors - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Sort+Colors+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Sort Colors:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 92,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Quick Sort Implementation",
      "description": "Problem: Implement Quick Sort using partition method (Lomuto or Hoare)."
    },
    "question2": {
      "name": "Kth Largest Element in an Array",
      "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
      "difficulty": "Medium"
    },
    "topics": [
      "Sorting",
      "Quick Sort"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Sorting algorithm for Quick Sort Implementation:\n\n1. Compare and swap elements\n2. Repeat until array is sorted\n3. Optimize based on algorithm choice\n\nKey Points:\n- Different algorithms for different use cases\n- Bubble/Selection: O(n\u00b2), simple\n- Merge/Quick: O(n log n), efficient",
          "code": "#include &lt;stdio.h&gt;\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int n = 5;\n    bubbleSort(arr, n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Kth Largest Element in an Array - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Kth+Largest+Element+in+an+Array+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Kth Largest Element in an Array:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 93,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Insertion Sort Implementation",
      "description": "Problem: Sort an array using insertion sort.\nStable sort. Good for nearly sorted arrays."
    },
    "question2": {
      "name": "Insertion Sort List",
      "link": "https://leetcode.com/problems/insertion-sort-list/",
      "difficulty": "Medium"
    },
    "topics": [
      "Sorting",
      "Insertion Sort"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To insert an element at a specific position in an array:\n\n1. Shift all elements from position 'pos' to the end, one step to the right\n2. Insert the new element at the specified position\n3. The array size increases by 1\n\nKey Points:\n- Start shifting from the end to avoid overwriting values\n- Position is 1-based (user-friendly), but array indexing is 0-based\n- Ensure the array has enough space for the new element",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, pos, x;\n    int arr[101]; // Extra space for insertion\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    scanf(\"%d %d\", &pos, &x);\n    \n    // Shift elements right from end\n    for (int i = n; i >= pos; i--) {\n        arr[i] = arr[i - 1];\n    }\n    \n    arr[pos - 1] = x;\n    \n    for (int i = 0; i <= n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Insertion Sort List - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Insertion+Sort+List+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Insertion Sort List:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 94,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Counting Sort Implementation",
      "description": "Problem: Sort array of non-negative integers using counting sort.\nFind max, build freq array, compute prefix sums, build output."
    },
    "question2": {
      "name": "Relative Sort Array",
      "link": "https://leetcode.com/problems/relative-sort-array/",
      "difficulty": "Easy"
    },
    "topics": [
      "Counting Sort"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Sorting algorithm for Counting Sort Implementation:\n\n1. Compare and swap elements\n2. Repeat until array is sorted\n3. Optimize based on algorithm choice\n\nKey Points:\n- Different algorithms for different use cases\n- Bubble/Selection: O(n\u00b2), simple\n- Merge/Quick: O(n log n), efficient",
          "code": "#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int n = 5;\n    bubbleSort(arr, n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Relative Sort Array - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Relative+Sort+Array+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Relative Sort Array:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 95,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Bucket Sort (Float Values 0\u20131)",
      "description": "Problem: Given n real numbers in [0,1), sort using bucket sort algorithm.\nDistribute into buckets, sort each, concatenate."
    },
    "question2": {
      "name": "Maximum Gap",
      "link": "https://leetcode.com/problems/maximum-gap/",
      "difficulty": "Hard"
    },
    "topics": [
      "Bucket Sort"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Sorting algorithm for Bucket Sort (Float Values 0\u20131):\n\n1. Compare and swap elements\n2. Repeat until array is sorted\n3. Optimize based on algorithm choice\n\nKey Points:\n- Different algorithms for different use cases\n- Bubble/Selection: O(n\u00b2), simple\n- Merge/Quick: O(n log n), efficient",
          "code": "#include &lt;stdio.h&gt;\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22};\n    int n = 5;\n    bubbleSort(arr, n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Maximum Gap - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Maximum+Gap+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Maximum Gap:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 96,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Counting Inversions in Array",
      "description": "Problem: Count number of inversions using modified merge sort.\nInversion if i < j and a[i] > a[j]."
    },
    "question2": {
      "name": "Reverse Pairs",
      "link": "https://leetcode.com/problems/reverse-pairs/",
      "difficulty": "Hard"
    },
    "topics": [
      "Inversions",
      "Merge Sort"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Counting Inversions in Array:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Reverse Pairs - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Reverse+Pairs+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Reverse Pairs:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 97,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Meeting Rooms Scheduling",
      "description": "Problem: Given meeting intervals, find minimum number of rooms required.\nSort by start time and use min-heap on end times."
    },
    "question2": {
      "name": "Meeting Rooms II",
      "link": "https://leetcode.com/problems/meeting-rooms-ii/",
      "difficulty": "Medium"
    },
    "topics": [
      "Intervals",
      "Priority Queue"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Meeting Rooms Scheduling:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Meeting Rooms II - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Meeting+Rooms+II+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Meeting Rooms II:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 98,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Merge Overlapping Intervals",
      "description": "Problem: Given intervals, merge all overlapping ones.\nSort first, then compare with previous."
    },
    "question2": {
      "name": "Merge Intervals",
      "link": "https://leetcode.com/problems/merge-intervals/",
      "difficulty": "Medium"
    },
    "topics": [
      "Intervals",
      "Sorting"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Merge Overlapping Intervals:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Merge Intervals - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Merge+Intervals+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Merge Intervals:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 99,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Find Peak Element in Array",
      "description": "Problem: Given target distance and cars\u2019 positions & speeds, compute number of fleets using reverse sorting and time calculation."
    },
    "question2": {
      "name": "Car Fleet",
      "link": "https://leetcode.com/problems/car-fleet/",
      "difficulty": "Medium"
    },
    "topics": [
      "Greedy",
      "Sorting"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Find Peak Element in Array:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Car Fleet - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Car+Fleet+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Car Fleet:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 100,
    "unit": "Unit VI: Sorting & Searching",
    "question1": {
      "title": "Count Inversions in Array",
      "description": "Problem: For each element, count how many smaller elements appear on right side.\nUse merge sort tree or BIT."
    },
    "question2": {
      "name": "Count of Smaller Numbers After Self",
      "link": "https://leetcode.com/problems/count-of-smaller-numbers-after-self/",
      "difficulty": "Hard"
    },
    "topics": [
      "Fenwick Tree",
      "Merge Sort Tree"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution approach for Count Inversions in Array:\n\n1. Read the input array\n2. Process according to problem requirements\n3. Output the result\n\nKey Points:\n- Understand the problem constraints\n- Choose appropriate data structure\n- Optimize for time and space complexity",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Process array based on problem\n    \n    // Output result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Count of Smaller Numbers After Self - Video Solution",
          "link": "https://www.youtube.com/results?search_query=Count+of+Smaller+Numbers+After+Self+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution approach for Count of Smaller Numbers After Self:\n\n1. Understand the problem constraints\n2. Identify the optimal algorithm/data structure\n3. Implement the solution\n4. Test with examples\n\nKey Points:\n- Read problem carefully\n- Consider edge cases\n- Optimize for time and space",
          "code": "// Solution template\nclass Solution {\npublic:\n    // Implement solution here\n    void solve() {\n        // Your code\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  }
]