[
  {
    "day": 1,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Insert an Element in an Array",
      "description": "Problem: Write a C program to insert an element x at a given 1-based position pos in an array of n integers. Shift existing elements to the right to make space.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers (the array)\n- Third line: integer pos (1-based position)\n- Fourth line: integer x (element to insert)\n\nOutput:\n- Print the updated array (n+1 integers) in a single line, space-separated\n\nExample:\nInput:\n5\n1 2 4 5 6\n3\n3\n\nOutput:\n1 2 3 4 5 6\n\nExplanation: Insert 3 at position 3, elements [4,5,6] shift right"
    },
    "question2": {
      "name": "Two Sum",
      "link": "https://leetcode.com/problems/two-sum/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Basics",
      "Hash Tables"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To insert an element at a specific position in an array:\n\n1. Shift all elements from position 'pos' to the end, one step to the right\n2. Insert the new element at the specified position\n3. The array size increases by 1\n\nKey Points:\n- Start shifting from the end to avoid overwriting values\n- Position is 1-based, but array indexing is 0-based\n- Ensure the array has enough space",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, pos, x;\n    int arr[101];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    scanf(\"%d %d\", &pos, &x);\n\n    for (int i = n; i >= pos; i--) {\n        arr[i] = arr[i - 1];\n    }\n\n    arr[pos - 1] = x;\n\n    for (int i = 0; i <= n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Solution Article",
          "link": "https://yourblog.com/day1-insert-element-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "NeetCode Explanation",
          "link": "https://www.youtube.com/watch?v=KLlXCFG5TnA"
        },
      {
        "explanation": "Find two numbers that add up to target using a brute-force approach.\n\nApproach:\n1. Use two nested loops to check all possible pairs\n2. Fix the first number using the outer loop\n3. For each fixed number, check the remaining numbers using the inner loop\n4. If nums[i] + nums[j] equals target, return their indices\n\nWhy it works:\n- All possible pairs are checked\n- No extra data structure is used\n- Guaranteed to find the correct pair if it exists",
        "code": "int* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n    static int result[2];\n    \n    for (int i = 0; i < numsSize; i++) {\n        for (int j = i + 1; j < numsSize; j++) {\n            if (nums[i] + nums[j] == target) {\n                result[0] = i;\n                result[1] = j;\n                *returnSize = 2;\n                return result;\n            }\n        }\n    }\n    \n    *returnSize = 0;\n    return NULL;\n}",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)",
        "type": "tutorial"
      }
      ]
    }
  },
  {
    "day": 2,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Delete an Element from an Array",
      "description": "Problem: Write a C program to delete the element at a given 1-based position pos from an array of n integers. Shift remaining elements to the left.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n- Third line: integer pos (1-based position to delete)\n\nOutput:\n- Print the updated array with (n-1) elements, space-separated\n\nExample:\nInput:\n5\n10 20 30 40 50\n2\n\nOutput:\n10 30 40 50\n\nExplanation: Delete position 2 (element 20), remaining elements shift left"
    },
    "question2": {
      "name": "Best Time to Buy and Sell Stock",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Operations",
      "Math"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To delete an element from an array at a given position:\n\n1. Shift all elements after position 'pos' one step to the left\n2. This overwrites the element to be deleted\n3. Reduce the array size by 1\n\nKey Points:\n- Start shifting from the deletion position forward\n- No need to clear the last element (it's now outside array bounds)\n- Position is 1-based for input, but array uses 0-based indexing",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, pos;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    scanf(\"%d\", &pos);\n    \n    // Shift elements left\n    for (int i = pos - 1; i < n - 1; i++) {\n        arr[i] = arr[i + 1];\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 2) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Solution Walkthrough",
          "link": "https://yourblog.com/day2-delete-element-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Video Tutorial",
          "link": "https://www.youtube.com/watch?v=1pkOgXD63yU"
        },
        {
          "type": "tutorial",
          "explanation": "Find maximum profit from buying and selling stock once.\n\nAlgorithm:\n1. Track minimum price seen so far\n2. For each price, calculate profit if selling today\n3. Update maximum profit\n\nKey Insight:\n- Buy at lowest price before current day\n- Sell at current price for maximum profit\n- One pass solution",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt;\n\nint maxProfit(int* prices, int pricesSize) {\n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n\n    for (int i = 0; i < pricesSize; i++) {\n        if (prices[i] < minPrice)\n            minPrice = prices[i];\n        if (prices[i] - minPrice > maxProfit)\n            maxProfit = prices[i] - minPrice;\n    }\n\n    return maxProfit;\n}\n\nint main() {\n    int prices[] = {7, 1, 5, 3, 6, 4};\n    int n = sizeof(prices) / sizeof(prices[0]);\n\n    int profit = maxProfit(prices, n);\n    printf(\"Maximum Profit: %d\\n\", profit);\n\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "LeetCode Editorial",
          "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/editorial/"
        }
      ]
    }
  },
  {
    "day": 3,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Linear Search with Comparison Count",
      "description": "Problem: Implement linear search to find key k in an array. Count and display the number of comparisons performed.\n\nInput:\n- First line: integer n (array size)\n- Second line: n space-separated integers\n- Third line: integer k (key to search)\n\nOutput:\n- Line 1: \"Found at index i\" OR \"Not Found\"\nLine 2: \"Comparisons = c\"\n\nExample:\nInput:\n5\n10 20 30 40 50\n30\n\nOutput:\nFound at index 2\nComparisons = 3\n\nExplanation: Compared with 10, 20, 30 (found at index 2 with 3 comparisons)"
    },
    "question2": {
      "name": "Missing number in array",
      "link": "https://practice.geeksforgeeks.org/problems/missing-number-in-array/0",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Searching"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linear search checks each element sequentially until finding the target or reaching the end.\n\nAlgorithm:\n1. Iterate through each element of the array\n2. Compare current element with the search key\n3. If found, return the index\n4. If not found after checking all elements, return -1\n\nKey Points:\n- Works on unsorted arrays\n- Time complexity is O(n) in worst case\n- Count comparisons to analyze performance",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n, k, comparisons = 0;\n    int arr[100];\n    int found = -1;\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    scanf(\"%d\", &k);\n    \n    for (int i = 0; i < n; i++) {\n        comparisons++;\n        if (arr[i] == k) {\n            found = i;\n            break;\n        }\n    }\n    \n    if (found != -1) {\n        printf(\"Found at index %d\\n\", found);\n    } else {\n        printf(\"Not Found\\n\");\n    }\n    printf(\"Comparisons = %d\\n\", comparisons);\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Algorithm Explanation",
          "link": "https://yourblog.com/day3-linear-search-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "GFG Video Solution",
          "link": "https://www.youtube.com/watch?v=WnPLSRLSANE"
        },
        {
          "type": "tutorial",
          "explanation": "Find missing number using sum formula or XOR.\n\nApproach 1 - Sum Formula:\n1. Calculate expected sum: n*(n+1)/2\n2. Calculate actual sum\n3. Difference is missing number\n\nApproach 2 - XOR:\n1. XOR all indices with all array values\n2. Pairs cancel out, leaving missing number",
          "code": "#include &lt;stdio.h&gt;\n\nint missingNumber(int* nums, int numsSize) {\n    int n = numsSize;\n    int expectedSum = n * (n + 1) / 2;\n    int actualSum = 0;\n    for (int i = 0; i &lt; n; i++) {\n        actualSum += nums[i];\n    }\n    return expectedSum - actualSum;\n}\n\nint main() {\n    int nums[] = {3, 0, 1};\n    int size = sizeof(nums)/sizeof(nums[0]);\n    printf(\"Missing number: %d\\n\", missingNumber(nums, size));\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "GeeksforGeeks Article",
          "link": "https://www.geeksforgeeks.org/find-the-missing-number/"
        }
      ]
    }
  },
  {
    "day": 4,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Reverse an Array In-Place",
      "description": "Problem: Given an array of n integers, reverse the array in-place using two-pointer approach.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n\nOutput:\n- Print the reversed array, space-separated\n\nExample:\nInput:\n5\n1 2 3 4 5\n\nOutput:\n5 4 3 2 1\n\nExplanation: Swap pairs from both ends: (1,5), (2,4), middle 3 stays"
    },
    "question2": {
      "name": "Remove Element",
      "link": "https://leetcode.com/problems/remove-element/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Reversal",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Reverse an array using the two-pointer technique:\n\n1. Use two pointers: one at start (left) and one at end (right)\n2. Swap elements at left and right pointers\n3. Move left pointer forward and right pointer backward\n4. Continue until left >= right\n\nKey Points:\n- In-place reversal (no extra array needed)\n- Efficient with O(n/2) swaps\n- Works for arrays of any size",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Two-pointer reversal\n    int left = 0, right = n - 1;\n    while (left < right) {\n        int temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Two-Pointer Approach",
          "link": "https://yourblog.com/day4-reverse-array-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Video Explanation",
          "link": "https://www.youtube.com/watch?v=Pcd1ii9P9ZI"
        },
        {
          "type": "tutorial",
          "explanation": "Remove all instances of val in-place using two pointers.\n\nApproach:\n1. Use slow pointer to track position to write\n2. Fast pointer scans through array\n3. Copy non-val elements to slow pointer position\n4. Return new length\n\nKey Points:\n- In-place modification\n- Order of elements can change\n- Return new array length",
          "code": "#include &lt;stdio.h&gt;\n\nint removeElement(int* nums, int numsSize, int val) {\n    int slow = 0;\n    for (int fast = 0; fast &lt; numsSize; fast++) {\n        if (nums[fast] != val) {\n            nums[slow] = nums[fast];\n            slow++;\n        }\n    }\n    return slow;\n}\n\nint main() {\n    int nums[] = {3, 2, 2, 3, 4};\n    int size = sizeof(nums)/sizeof(nums[0]);\n    int val = 3;\n    int newLength = removeElement(nums, size, val);\n    printf(\"New array: \");\n    for (int i = 0; i &lt; newLength; i++) {\n        printf(\"%d \", nums[i]);\n    }\n    printf(\"\\nNew length: %d\\n\", newLength);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "LeetCode Editorial",
          "link": "https://leetcode.com/problems/remove-element/editorial/"
        }
      ]
    }
  },
  {
    "day": 5,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Arrange Arrival Logs",
      "description": "Problem: A system receives two separate logs of user arrival times from two different servers. Each log is already sorted in ascending order. Your task is to create a single chronological log that preserves the correct order of arrivals.\n\nInput:\n- First line: integer p (number of entries in server log 1)\n- Second line: p sorted integers representing arrival times from server 1\n- Third line: integer q (number of entries in server log 2)\n- Fourth line: q sorted integers representing arrival times from server 2)\n\nOutput:\n- Print a single line containing all arrival times in chronological order, separated by spaces\n\nExample:\nInput:\n5\n10 20 30 50 70\n4\n15 25 40 60\n\nOutput:\n10 15 20 25 30 40 50 60 70\n\nExplanation: Compare the next unprocessed arrival time from both logs and append the earlier one to the final log until all entries are processed"
    },
    "question2": {
      "name": "Merge Sorted Array",
      "link": "https://leetcode.com/problems/merge-sorted-array/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Merge",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Merge two sorted arrays using two-pointer technique:\n\n1. Use pointers i and j for array1 and array2\n2. Compare elements at both pointers\n3. Add smaller element to result and move that pointer\n4. When one array is exhausted, copy remaining elements from other array\n\nKey Points:\n- Maintains sorted order\n- Time complexity O(n + m)\n- Requires extra space for result array",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n1, n2;\n    int arr1[100], arr2[100], result[200];\n    \n    scanf(\"%d\", &n1);\n    for (int i = 0; i < n1; i++) {\n        scanf(\"%d\", &arr1[i]);\n    }\n    \n    scanf(\"%d\", &n2);\n    for (int i = 0; i < n2; i++) {\n        scanf(\"%d\", &arr2[i]);\n    }\n    \n    int i = 0, j = 0, k = 0;\n    while (i < n1 && j < n2) {\n        if (arr1[i] <= arr2[j]) {\n            result[k++] = arr1[i++];\n        } else {\n            result[k++] = arr2[j++];\n        }\n    }\n    \n    while (i < n1) result[k++] = arr1[i++];\n    while (j < n2) result[k++] = arr2[j++];\n    \n    for (int i = 0; i < k; i++) {\n        printf(\"%d\", result[i]);\n        if (i < k - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(n + m)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "LeetCode Video",
          "link": "https://www.youtube.com/watch?v=P1Ic85RarKY"
        },
        {
          "type": "tutorial",
          "explanation": "Merge nums2 into nums1 (which has enough space) in-place.\n\nApproach:\n1. Start from the end of both arrays\n2. Compare elements and place larger one at end of nums1\n3. Move pointers backward\n4. Copy remaining elements from nums2 if any\n\nKey Points:\n- Work backwards to avoid overwriting\n- nums1 has space for both arrays\n- In-place solution",
          "code": "#include &lt;stdio.h&gt;\n\nvoid merge(int* nums1, int m, int* nums2, int n) {\n    int i = m - 1;\n    int j = n - 1;\n    int k = m + n - 1;\n\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] &gt; nums2[j]) {\n            nums1[k--] = nums1[i--];\n        } else {\n            nums1[k--] = nums2[j--];\n        }\n    }\n\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n\nint main() {\n    int nums1[9] = {1, 3, 5, 0, 0, 0};\n    int nums2[3] = {2, 4, 6};\n    int m = 3, n = 3;\n\n    merge(nums1, m, nums2, n);\n\n    printf(\"Merged array: \");\n    for (int i = 0; i &lt; m + n; i++) {\n        printf(\"%d \", nums1[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 6,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Remove Duplicates from Sorted Array",
      "description": "Problem: Given a sorted array of n integers, remove duplicates in-place. Print only unique elements in order.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers (sorted array)\n\nOutput:\n- Print unique elements only, space-separated\n\nExample:\nInput:\n6\n1 1 2 2 3 3\n\nOutput:\n1 2 3\n\nExplanation: Keep first occurrence of each element: 1, 2, 3"
    },
    "question2": {
      "name": "Move Zeroes",
      "link": "https://leetcode.com/problems/move-zeroes/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Cleanup"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Remove duplicates from sorted array using two pointers:\n\n1. Use slow pointer to track position of unique elements\n2. Fast pointer scans through array\n3. When different element found, copy to slow+1 position\n4. Return count of unique elements\n\nKey Points:\n- Array is sorted, duplicates are adjacent\n- First element is always unique\n- In-place modification",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    int slow = 0;\n    for (int fast = 1; fast < n; fast++) {\n        if (arr[fast] != arr[slow]) {\n            slow++;\n            arr[slow] = arr[fast];\n        }\n    }\n    \n    for (int i = 0; i <= slow; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < slow) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Move Zeroes - Video Solution",
          "link": "https://www.youtube.com/watch?v=aayNRwUN3Do"
        },
        {
          "type": "tutorial",
          "explanation": "Move all zeroes to end while maintaining relative order of non-zero elements.\n\nApproach:\n1. Use slow pointer for non-zero position\n2. Fast pointer scans array\n3. Swap non-zero elements to front\n4. Zeroes automatically move to end\n\nKey Points:\n- In-place modification\n- Maintain relative order\n- Two-pointer technique",
          "code": "#include &lt;stdio.h&gt;\n\nvoid moveZeroes(int* nums, int size) {\n    int slow = 0;\n\n    for (int fast = 0; fast &lt; size; fast++) {\n        if (nums[fast] != 0) {\n            int temp = nums[slow];\n            nums[slow] = nums[fast];\n            nums[fast] = temp;\n            slow++;\n        }\n    }\n}\n\nint main() {\n    int nums[] = {0, 1, 0, 3, 12};\n    int size = sizeof(nums) / sizeof(nums[0]);\n\n    moveZeroes(nums, size);\n\n    printf(\"Array after moving zeros: \");\n    for (int i = 0; i &lt; size; i++) {\n        printf(\"%d \", nums[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 7,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Recursive Fibonacci",
      "description": "Problem: Write a recursive function fib(n) to compute the n-th Fibonacci number where fib(0)=0 and fib(1)=1.\n\nInput:\n- Single integer n\n\nOutput:\n- Print the n-th Fibonacci number\n\nExample:\nInput:\n6\n\nOutput:\n8\n\nExplanation: Sequence: 0,1,1,2,3,5,8 at positions 0,1,2,3,4,5,6"
    },
    "question2": {
      "name": "Fibonacci Number",
      "link": "https://leetcode.com/problems/fibonacci-number/",
      "difficulty": "Easy"
    },
    "topics": [
      "Recursion"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Recursive solution for Fibonacci:\n\n1. Define base cases: fib(0) = 0, fib(1) = 1\n2. Recursive case: fib(n) = fib(n-1) + fib(n-2)\n3. Ensure progress toward base case\n\nKey Points:\n- Recursion uses call stack\n- Watch for stack overflow with large inputs\n- Consider iterative alternative for better space complexity\n- Can use memoization to optimize",
          "code": "#include &lt;stdio.h&gt;\n\nint fib(int n) {\n    // Base cases\n    if (n <= 1) return n;\n    \n    // Recursive case\n    return fib(n - 1) + fib(n - 2);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    printf(\"%d\\n\", fib(n));\n    return 0;\n}",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Fibonacci Number - Video Solution",
          "link": "https://www.youtube.com/watch?v=3lpNp5Ojvrw"
        },
        {
          "type": "tutorial",
          "explanation": "Calculate Fibonacci number efficiently.\n\nApproach 1 - Iterative (Optimal):\n1. Use two variables to track previous two numbers\n2. Iterate from 2 to n\n3. Update variables in each iteration\n\nApproach 2 - Recursive with Memoization:\n1. Cache computed values\n2. Avoid redundant calculations\n\nKey Points:\n- Iterative is O(n) time, O(1) space\n- Recursive is simpler but less efficient",
          "code": "class Solution {\npublic:\n    int fib(int n) {\n        if (n <= 1) return n;\n        \n        int prev2 = 0, prev1 = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            int curr = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        \n        return prev1;\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 8,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Compute Power Using Recursion",
      "description": "Problem: Given integers a and b, compute a^b using recursion without using pow() function.\n\nInput:\n- Two space-separated integers a and b\n\nOutput:\n- Print a raised to power b\n\nExample:\nInput:\n2 5\n\nOutput:\n32\n\nExplanation: 2^5 = 2 * 2 * 2 * 2 * 2 = 32"
    },
    "question2": {
      "name": "Power of Two",
      "link": "https://leetcode.com/problems/power-of-two/",
      "difficulty": "Easy"
    },
    "topics": [
      "Recursion",
      "Math"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Compute power using recursion:\n\n1. Base case: a^0 = 1\n2. Recursive case: a^b = a * a^(b-1)\n3. Can optimize with divide and conquer for O(log n)\n\nKey Points:\n- Simple recursion is O(b) time\n- Fast exponentiation uses a^(2k) = (a^k)^2\n- Handle negative exponents if needed",
          "code": "#include &lt;stdio.h&gt;\n\nint power(int a, int b) {\n    // Base case\n    if (b == 0) return 1;\n    \n    // Recursive case\n    return a * power(a, b - 1);\n}\n\nint main() {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    printf(\"%d\\n\", power(a, b));\n    return 0;\n}",
          "timeComplexity": "O(b)",
          "spaceComplexity": "O(b)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Power of Two - Video Solution",
          "link": "https://www.youtube.com/watch?v=H2bjttEV4Vc"
        },
        {
          "type": "tutorial",
          "explanation": "Check if n is a power of 2.\n\nApproach 1 - Bit Manipulation:\n1. Power of 2 has exactly one bit set\n2. Use n & (n-1) == 0 trick\n3. Also check n > 0\n\nApproach 2 - Recursive Division:\n1. Keep dividing by 2\n2. Check if remainder is 0\n3. Final result should be 1\n\nKey Points:\n- Bit manipulation is O(1)\n- Powers of 2: 1, 2, 4, 8, 16, ...",
          "code": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        if (n <= 0) return false;\n        return (n & (n - 1)) == 0;\n    }\n};",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 9,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Mirror the Code Name",
      "description": "Problem: A secret system stores code names in forward order. To display them in mirror format, you must transform the given code name so that its characters appear in the opposite order.\n\nInput:\n- Single line: a lowercase string containing only alphabetic characters (no spaces)\n\nOutput:\n- Print the transformed code name after applying the mirror operation\n\nExample:\nInput:\nhello\n\nOutput:\nolleh\n\nExplanation: The first character moves to the last position, the second to the second-last, and so on until the entire string is mirrored"
    },
    "question2": {
      "name": "Reverse String",
      "link": "https://leetcode.com/problems/reverse-string/",
      "difficulty": "Easy"
    },
    "topics": [
      "String",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Reverse a string using two-pointer technique:\n\n1. Use two pointers: one at start, one at end\n2. Swap characters at both pointers\n3. Move pointers toward center\n4. Stop when pointers meet\n\nKey Points:\n- In-place reversal\n- Works for strings of any length\n- O(n/2) swaps needed",
          "code": "#include &lt;stdio.h&gt;\n#include <string.h>\n\nint main() {\n    char str[1000];\n    scanf(\"%s\", str);\n    \n    int left = 0;\n    int right = strlen(str) - 1;\n    \n    while (left < right) {\n        char temp = str[left];\n        str[left] = str[right];\n        str[right] = temp;\n        left++;\n        right--;\n    }\n    \n    printf(\"%s\\n\", str);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Reverse String - Video Solution",
          "link": "https://www.youtube.com/watch?v=_d0T_2Lk2qA"
        },
        {
          "type": "tutorial",
          "explanation": "Reverse string in-place (array of characters).\n\nApproach:\n1. Use two pointers from both ends\n2. Swap characters\n3. Move pointers toward center\n4. Must modify input array directly\n\nKey Points:\n- In-place requirement (O(1) space)\n- Two-pointer technique\n- Return void, modify input",
          "code": "#include &lt;stdio.h&gt;\n\nvoid reverseString(char* s, int size) {\n    int left = 0, right = size - 1;\n\n    while (left &lt; right) {\n        char temp = s[left];\n        s[left] = s[right];\n        s[right] = temp;\n        left++;\n        right--;\n    }\n}\n\nint main() {\n    char s[] = {'h','e','l','l','o'};\n    int size = sizeof(s) / sizeof(s[0]);\n\n    reverseString(s, size);\n\n    printf(\"Reversed string: \");\n    for (int i = 0; i &lt; size; i++) {\n        printf(\"%c\", s[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 10,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Check Palindrome",
      "description": "Problem: Read a string and check if it is a palindrome using two-pointer comparison.\n\nInput:\n- Single line: string s\n\nOutput:\n- Print YES if palindrome, otherwise NO\n\nExample:\nInput:\nlevel\n\nOutput:\nYES\n\nExplanation: String reads same forwards and backwards"
    },
    "question2": {
      "name": "Intersection of two arrays",
      "link": "https://leetcode.com/problems/intersection-of-two-arrays-ii/description/",
      "difficulty": "Easy"
    },
    "topics": [
      "Palindrome Check",
      "Array"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Check if string is palindrome using two pointers:\n\n1. Use left pointer at start, right at end\n2. Compare characters at both positions\n3. If different, not palindrome\n4. Move pointers toward center\n5. If all match, it's palindrome\n\nKey Points:\n- Case-sensitive comparison\n- Works for odd and even length strings\n- Early termination on mismatch",
          "code": "#include &lt;stdio.h&gt;\n#include <string.h>\n#include <stdbool.h>\n\nint main() {\n    char str[1000];\n    scanf(\"%s\", str);\n    \n    int left = 0;\n    int right = strlen(str) - 1;\n    bool isPalindrome = true;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            isPalindrome = false;\n            break;\n        }\n        left++;\n        right--;\n    }\n    \n    printf(\"%s\\n\", isPalindrome ? \"YES\" : \"NO\");\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Intersection of Two Arrays II - Video",
          "link": "https://www.youtube.com/watch?v=jo7E5K_pJ18"
        },
        {
          "type": "tutorial",
          "explanation": "Find intersection of two arrays (with duplicates).\n\nApproach 1 - Hash Map:\n1. Count frequency of elements in nums1\n2. Iterate through nums2\n3. If element exists in map and count > 0, add to result\n4. Decrement count\n\nApproach 2 - Sorting:\n1. Sort both arrays\n2. Use two pointers\n3. Add common elements\n\nKey Points:\n- Handle duplicates\n- Can appear multiple times in result",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define MAX 10000\n\ntypedef struct {\n    int key;\n    int count;\n} HashNode;\n\nHashNode hash[MAX];\nint hashSize = 0;\n\nint findIndex(int key) {\n    for (int i = 0; i &lt; hashSize; i++) {\n        if (hash[i].key == key) return i;\n    }\n    return -1;\n}\n\nint main() {\n    int n1, n2;\n    scanf(\"%d\", &n1);\n    int nums1[n1];\n    for (int i = 0; i &lt; n1; i++) scanf(\"%d\", &nums1[i]);\n\n    scanf(\"%d\", &n2);\n    int nums2[n2];\n    for (int i = 0; i &lt; n2; i++) scanf(\"%d\", &nums2[i]);\n\n    // Count frequency of nums1\n    for (int i = 0; i &lt; n1; i++) {\n        int idx = findIndex(nums1[i]);\n        if (idx == -1) hash[hashSize++] = (HashNode){nums1[i], 1};\n        else hash[idx].count++;\n    }\n\n    // Find intersection with nums2\n    printf(\"Intersection: \");\n    for (int i = 0; i &lt; n2; i++) {\n        int idx = findIndex(nums2[i]);\n        if (idx != -1 &amp;&amp; hash[idx].count &gt; 0) {\n            printf(\"%d \", nums2[i]);\n            hash[idx].count--;\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(min(n, m))"
        }
      ]
    }
  },
 {
    "day": 11,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Matrix Addition",
      "description": "Problem: Write a program to perform addition of two matrices having the same dimensions. The sum of two matrices is obtained by adding corresponding elements of the matrices.\n\nInput:\n- First line: two integers m and n representing the number of rows and columns\n- Next m lines: n integers each representing the elements of the first matrix\n- Next m lines: n integers each representing the elements of the second matrix\n\nOutput:\n- Print the resultant matrix after addition, with each row on a new line and elements separated by spaces\n\nExample:\nInput:\n3 3\n1 2 3\n4 5 6\n7 8 9\n9 8 7\n6 5 4\n3 2 1\n\nOutput:\n10 10 10\n10 10 10\n10 10 10\n\nExplanation:\nEach element of the result matrix is the sum of the corresponding elements from the two input matrices.\n\nTest Cases:\n\nTest Case 1:\nInput:\n2 2\n1 2\n3 4\n5 6\n7 8\nOutput:\n6 8\n10 12\n\nTest Case 2:\nInput:\n1 3\n10 20 30\n1 2 3\nOutput:\n11 22 33\n\nTest Case 3:\nInput:\n3 1\n1\n2\n3\n4\n5\n6\nOutput:\n5\n7\n9"
    },
    "question2": {
      "name": "Transpose Matrix",
      "link": "https://leetcode.com/problems/transpose-matrix/",
      "difficulty": "Easy"
    },
    "topics": [
      "Matrix"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Matrix addition is performed element-wise:\n\n1. Both matrices must have same dimensions (m × n)\n2. Add corresponding elements: result[i][j] = mat1[i][j] + mat2[i][j]\n3. Store in result matrix\n4. Print the result\n\nKey Points:\n- Matrices must have same dimensions\n- Addition is commutative: A + B = B + A\n- Time complexity is O(m × n)",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int m, n;\n    int mat1[100][100], mat2[100][100], result[100][100];\n    \n    scanf(\"%d %d\", &m, &n);\n    \n    // Read first matrix\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &mat1[i][j]);\n        }\n    }\n    \n    // Read second matrix\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &mat2[i][j]);\n        }\n    }\n    \n    // Add matrices\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            result[i][j] = mat1[i][j] + mat2[i][j];\n        }\n    }\n    \n    // Print result\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%d\", result[i][j]);\n            if (j < n - 1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}",
          "timeComplexity": "O(m × n)",
          "spaceComplexity": "O(m × n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Transpose Matrix - Video Solution",
          "link": "https://www.youtube.com/watch?v=hA_yvtCpjsg"
        },
        {
          "type": "tutorial",
          "explanation": "Approach:\n\n1. Find number of rows m and columns n\n2. Create a new matrix transpose of size n × m\n3. Traverse the original matrix using two nested loops:\n   - Outer loop for rows (i)\n   - Inner loop for columns (j)\n4. Assign:\n   transpose[j][i] = matrix[i][j]\n5. Return the transposed matrix\n\nKey Points:\n- Rows become columns and columns become rows\n- Works for rectangular matrices as well\n- Uses extra space for the transposed matrix",
          "code": "int** transpose(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes) {\n    int m = matrixSize;\n    int n = matrixColSize[0];\n\n    returnSize = n;\n    returnColumnSizes = (int)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        (returnColumnSizes)[i] = m;\n    }\n\n    int result = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        result[i] = (int*)malloc(m * sizeof(int));\n    }\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n\n    return result;\n}",
          "timeComplexity": "O(m × n)",
          "spaceComplexity": "O(m × n)"
        }
      ]
    }
  },
  {
    "day": 12,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Check Symmetric Matrix",
      "description": "Problem: Write a program to check whether a given matrix is symmetric. A matrix is said to be symmetric if it is a square matrix and is equal to its transpose (i.e., element at position [i][j] is equal to element at position [j][i] for all valid i and j).\n\nInput:\n- First line: two integers m and n representing the number of rows and columns\n- Next m lines: n integers each representing the elements of the matrix\n\nOutput:\n- Print \"Symmetric Matrix\" if the given matrix is symmetric\n- Otherwise, print \"Not a Symmetric Matrix\"\n\nExample:\nInput:\n3 3\n1 2 3\n2 4 5\n3 5 6\n\nOutput:\nSymmetric Matrix\n\nExplanation:\nThe matrix is square (3 × 3) and for every i and j, element[i][j] = element[j][i].\n\nTest Cases:\n\nTest Case 1:\nInput:\n2 2\n1 2\n2 1\nOutput:\nSymmetric Matrix\n\nTest Case 2:\nInput:\n3 3\n1 0 1\n2 3 4\n1 4 5\nOutput:\nNot a Symmetric Matrix\n\nTest Case 3:\nInput:\n2 3\n1 2 3\n4 5 6\nOutput:\nNot a Symmetric Matrix"
    },
    "question2": {
      "name": "Toeplitz Matrix",
      "link": "https://leetcode.com/problems/toeplitz-matrix/",
      "difficulty": "Easy"
    },
    "topics": [
      "Matrix Diagonal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Check if matrix is symmetric:\n\n1. First check if matrix is square (m == n)\n2. Compare element at [i][j] with element at [j][i]\n3. If any pair doesn't match, not symmetric\n4. If all pairs match, it's symmetric\n\nKey Points:\n- Must be square matrix\n- A[i][j] must equal A[j][i] for all i, j\n- Only need to check upper or lower triangle",
          "code": "#include &lt;stdio.h&gt;\n#include <stdbool.h>\n\nint main() {\n    int m, n;\n    int mat[100][100];\n    \n    scanf(\"%d %d\", &m, &n);\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    \n    bool isSymmetric = true;\n    \n    // Check if square\n    if (m != n) {\n        isSymmetric = false;\n    } else {\n        // Check symmetry\n        for (int i = 0; i < m && isSymmetric; i++) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] != mat[j][i]) {\n                    isSymmetric = false;\n                    break;\n                }\n            }\n        }\n    }\n    \n    printf(\"%s\\n\", isSymmetric ? \"Symmetric Matrix\" : \"Not a Symmetric Matrix\");\n    return 0;\n}",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Toeplitz Matrix - Video Solution",
          "link": "https://www.youtube.com/watch?v=r1Al6vVg2VQ"
        },
        {
          "type": "tutorial",
          "explanation": "Approach:\n\nA matrix is Toeplitz if:\n\nmatrix[i][j] = matrix[i - 1][j - 1]\n\nfor all valid i > 0 and j > 0.\n\nSteps:\n1. Start checking from cell (1, 1) since (0, 0) has no top-left neighbor\n2. Traverse the matrix using nested loops\n3. For every cell (i, j), compare it with (i - 1, j - 1)\n4. If any mismatch is found, return false\n5. If all diagonal comparisons pass, return true\n\nKey Points:\n- Each diagonal from top-left to bottom-right must have same elements\n- Works for rectangular matrices\n- No extra space required",
          "code": "bool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize) {\n    \n    int m = matrixSize;\n    int n = matrixColSize[0];\n\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            if (matrix[i][j] != matrix[i - 1][j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
          "timeComplexity": "O(m × n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 13,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Boundary-to-Center Matrix Walk",
      "description": "Problem: You are given a rectangular matrix of integers. Starting from the outer boundary, traverse the matrix in a clockwise manner and continue moving inward layer by layer until all elements are visited.\n\nInput:\n- First line: two integers r and c representing the number of rows and columns\n- Next r lines: c integers each representing the matrix elements\n\nOutput:\n- Print all visited elements in the order of traversal, separated by spaces\n\nExample:\nInput:\n3 3\n1 2 3\n4 5 6\n7 8 9\n\nOutput:\n1 2 3 6 9 8 7 4 5\n\nExplanation:\nThe traversal begins along the top row, proceeds down the rightmost column, then moves across the bottom row in reverse, and finally goes up the leftmost column. The same pattern repeats for the inner submatrix.\n\nTest Cases:\n\nTest Case 1:\nInput:\n2 3\n1 2 3\n4 5 6\nOutput:\n1 2 3 6 5 4\n\nTest Case 2:\nInput:\n3 1\n7\n8\n9\nOutput:\n7 8 9"
    },
    "question2": {
      "name": "Spiral Matrix",
      "link": "https://leetcode.com/problems/spiral-matrix/",
      "difficulty": "Medium"
    },
    "topics": [
      "Matrix Spiral"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Traverse matrix in spiral order using boundaries:\n\n1. Maintain four boundaries: top, bottom, left, right\n2. Traverse top row (left to right)\n3. Traverse right column (top to bottom)\n4. Traverse bottom row (right to left) if exists\n5. Traverse left column (bottom to top) if exists\n6. Shrink boundaries and repeat\n\nKey Points:\n- Update boundaries after each direction\n- Check if boundaries are valid before traversing\n- Handle single row/column cases",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int r, c;\n    int mat[100][100];\n    \n    scanf(\"%d %d\", &r, &c);\n    \n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    \n    int top = 0, bottom = r - 1, left = 0, right = c - 1;\n    \n    while (top <= bottom && left <= right) {\n        // Top row\n        for (int j = left; j <= right; j++) {\n            printf(\"%d \", mat[top][j]);\n        }\n        top++;\n        \n        // Right column\n        for (int i = top; i <= bottom; i++) {\n            printf(\"%d \", mat[i][right]);\n        }\n        right--;\n        \n        // Bottom row (if exists)\n        if (top <= bottom) {\n            for (int j = right; j >= left; j--) {\n                printf(\"%d \", mat[bottom][j]);\n            }\n            bottom--;\n        }\n        \n        // Left column (if exists)\n        if (left <= right) {\n            for (int i = bottom; i >= top; i--) {\n                printf(\"%d \", mat[i][left]);\n            }\n            left++;\n        }\n    }\n    \n    printf(\"\\n\");\n    return 0;\n}",
          "timeComplexity": "O(m × n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Spiral Matrix - Video Solution",
          "link": "https://www.youtube.com/watch?v=BJnMZNwUk1M"
        },
        {
          "type": "tutorial",
          "explanation": "Return all elements in spiral order.\n\nApproach:\n1. Use four boundary variables\n2. Traverse in order: right, down, left, up\n3. Shrink boundaries after each direction\n4. Continue until all elements visited\n\nKey Points:\n- Handle edge cases (empty, single row/column)\n- Check boundaries before each traversal\n- Use dynamic array to store result",
          "code": "int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\n    if (matrixSize == 0 || matrixColSize[0] == 0) {\n        returnSize = 0;\n        return NULL;\n    }\n\n    int m = matrixSize;\n    int n = matrixColSize[0];\n    int result = (int*)malloc(sizeof(int) * m * n);\n    int index = 0;\n\n    int top = 0, bottom = m - 1;\n    int left = 0, right = n - 1;\n\n    while (top <= bottom && left <= right) {\n        for (int i = left; i <= right; i++)\n            result[index++] = matrix[top][i];\n        top++;\n\n        for (int i = top; i <= bottom; i++)\n            result[index++] = matrix[i][right];\n        right--;\n\n        if (top <= bottom) {\n            for (int i = right; i >= left; i--)\n                result[index++] = matrix[bottom][i];\n            bottom--;\n        }\n\n        if (left <= right) {\n            for (int i = bottom; i >= top; i--)\n                result[index++] = matrix[i][left];\n            left++;\n        }\n    }\n\n    *returnSize = index;\n    return result;\n}",
          "timeComplexity": "O(m × n)",
          "spaceComplexity": "O(m × n)"
        }
      ]
    }
  },
  {
    "day": 14,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Check Identity Matrix",
      "description": "Problem: Write a program to check whether a given square matrix is an Identity Matrix. An identity matrix is a square matrix in which all diagonal elements are 1 and all non-diagonal elements are 0.\n\nInput:\n- First line: integer n representing number of rows and columns\n- Next n lines: n integers each representing the matrix elements\n\nOutput:\n- Print \"Identity Matrix\" if the matrix satisfies the condition\n- Otherwise, print \"Not an Identity Matrix\"\n\nExample:\nInput:\n3\n1 0 0\n0 1 0\n0 0 1\n\nOutput:\nIdentity Matrix"
    },
    "question2": {
      "name": "Rotate Image",
      "link": "https://leetcode.com/problems/rotate-image/",
      "difficulty": "Medium"
    },
    "topics": [
      "Matrix Properties"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Check if matrix is identity matrix:\n\n1. Must be square matrix (n × n)\n2. Diagonal elements (i == j) must be 1\n3. Non-diagonal elements (i != j) must be 0\n4. Check all elements\n\nKey Points:\n- Identity matrix is always square\n- Diagonal: mat[i][i] = 1\n- Off-diagonal: mat[i][j] = 0 where i ≠ j",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main() {\n    int n;\n    int mat[100][100];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    \n    bool isIdentity = true;\n    \n    for (int i = 0; i < n && isIdentity; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                if (mat[i][j] != 1) {\n                    isIdentity = false;\n                    break;\n                }\n            } else {\n                if (mat[i][j] != 0) {\n                    isIdentity = false;\n                    break;\n                }\n            }\n        }\n    }\n    \n    printf(\"%s\\n\", isIdentity ? \"Identity Matrix\" : \"Not an Identity Matrix\");\n    return 0;\n}",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Rotate Image - Video Solution",
          "link": "https://www.youtube.com/watch?v=fMSJSS7eO1w"
        },
        {
          "type": "tutorial",
          "explanation": "Rotate n×n matrix 90 degrees clockwise in-place.\n\nApproach:\n1. Transpose the matrix (swap mat[i][j] with mat[j][i])\n2. Reverse each row\n3. Result is 90-degree clockwise rotation\n\nAlternative: Rotate layer by layer\n\nKey Points:\n- In-place rotation required\n- Transpose + reverse = rotate 90°\n- Must handle square matrix only",
          "code": "void rotate(int** matrix, int matrixSize, int* matrixColSize) {\n    int n = matrixSize;\n\n    // Transpose the matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = temp;\n        }\n    }\n\n    // Reverse each row\n    for (int i = 0; i < n; i++) {\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int temp = matrix[i][left];\n            matrix[i][left] = matrix[i][right];\n            matrix[i][right] = temp;\n            left++;\n            right--;\n        }\n    }\n}",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 15,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Matrix Diagonal Sum",
      "description": "Problem: Given a matrix, calculate the sum of its primary diagonal elements. The primary diagonal consists of elements where row index equals column index.\n\nInput:\n- First line: two integers m and n\n- Next m lines: n integers each\n\nOutput:\n- Print the sum of the primary diagonal elements\n\nExample:\nInput:\n3 3\n1 2 3\n4 5 6\n7 8 9\n\nOutput:\n15\n\nExplanation:\n1 + 5 + 9 = 15"
    },
    "question2": {
      "name": "Set Matrix Zeroes",
      "link": "https://leetcode.com/problems/set-matrix-zeroes/",
      "difficulty": "Medium"
    },
    "topics": [
      "Matrix"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Calculate sum of diagonal elements:\n\n1. Primary diagonal: elements where i == j\n2. Sum only these elements\n3. Works only for square matrices\n\nKey Points:\n- Diagonal elements: mat[0][0], mat[1][1], ..., mat[n-1][n-1]\n- For non-square matrix, min(m, n) diagonal elements\n- Can also calculate secondary diagonal (i + j == n - 1)",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int m, n;\n    int mat[100][100];\n    \n    scanf(\"%d %d\", &m, &n);\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    \n    int sum = 0;\n    int minDim = m < n ? m : n;\n    \n    for (int i = 0; i < minDim; i++) {\n        sum += mat[i][i];\n    }\n    \n    printf(\"%d\\n\", sum);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
  {
    "type": "video",
    "label": "Set Matrix Zeroes - Video Solution",
    "link": "https://www.youtube.com/watch?v=T41rL0L3Pnw"
  },
  {
    "type": "tutorial",
    "explanation": "Set entire row and column to 0 if element is 0.\n\nApproach (O(1) space):\n1. Use first row and column as markers\n2. Scan matrix, mark first row/column if 0 found\n3. Use markers to set zeros\n4. Handle first row/column separately\n\nKey Points:\n- Must modify in-place\n- O(1) space solution uses matrix itself\n- Process from bottom-right to preserve markers",
    "code": "#include &lt;stdio.h&gt;\n\nvoid setZeroes(int matrix[200][200], int m, int n) {\n    int firstRowZero = 0;\n    int firstColZero = 0;\n\n    // Check first column\n    for (int i = 0; i < m; i++) {\n        if (matrix[i][0] == 0) {\n            firstColZero = 1;\n            break;\n        }\n    }\n\n    // Check first row\n    for (int j = 0; j < n; j++) {\n        if (matrix[0][j] == 0) {\n            firstRowZero = 1;\n            break;\n        }\n    }\n\n    // Mark rows and columns\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            if (matrix[i][j] == 0) {\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n\n    // Zero rows\n    for (int i = 1; i < m; i++) {\n        if (matrix[i][0] == 0) {\n            for (int j = 1; j < n; j++) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    // Zero columns\n    for (int j = 1; j < n; j++) {\n        if (matrix[0][j] == 0) {\n            for (int i = 1; i < m; i++) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    // Zero first column\n    if (firstColZero) {\n        for (int i = 0; i < m; i++) {\n            matrix[i][0] = 0;\n        }\n    }\n\n    // Zero first row\n    if (firstRowZero) {\n        for (int j = 0; j < n; j++) {\n            matrix[0][j] = 0;\n        }\n    }\n}",
    "timeComplexity": "O(m × n)",
    "spaceComplexity": "O(1)"
  }
]

    }
  },
  {
    "day": 16,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Frequency Counter in Array",
      "description": "Problem: Given an array of integers, count the frequency of each distinct element and print the result.\n\nInput:\n- First line: integer n (size of array)\n- Second line: n integers\n\nOutput:\n- Print each element followed by its frequency in the format element:count\n\nExample:\nInput:\n5\n1 2 2 3 1\n\nOutput:\n1:2 2:2 3:1"
    },
    "question2": {
      "name": "Rotate Array",
      "link": "https://leetcode.com/problems/rotate-array/description/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Count",
      "HashMap Logic"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Count frequency of elements using hash map (or frequency array):\n\n1. Iterate through array\n2. For each element, increment its count in map\n3. Print all element-frequency pairs\n\nKey Points:\n- Use hash map for arbitrary values\n- Use frequency array if values in limited range\n- Maintains insertion order with ordered map",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    int freq[1001] = {0}; // Assuming values 0-1000\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n        freq[arr[i]]++;\n    }\n    \n    // Print in order of first appearance\n    for (int i = 0; i < n; i++) {\n        if (freq[arr[i]] > 0) {\n            printf(\"%d:%d \", arr[i], freq[arr[i]]);\n            freq[arr[i]] = 0; // Mark as printed\n        }\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(k) where k is range of values"
        }
      ],
      "question2": [
  {
    "type": "video",
    "label": "Rotate Array - Video Solution",
    "link": "https://www.youtube.com/watch?v=BHr381Guz3Y"
  },
  {
    "type": "tutorial",
    "explanation": "Rotate array to right by k steps.\n\nApproach (Reverse Method):\n1. Reverse entire array\n2. Reverse first k elements\n3. Reverse remaining n-k elements\n\nAlternative: Use extra space to copy\n\nKey Points:\n- k can be > n, use k % n\n- In-place solution preferred\n- Three reverses achieve rotation",
    "code": "void reverse(int* nums, int start, int end) {\n    while (start < end) {\n        int temp = nums[start];\n        nums[start] = nums[end];\n        nums[end] = temp;\n        start++;\n        end--;\n    }\n}\n\nvoid rotate(int* nums, int numsSize, int k) {\n    if (numsSize == 0) return;\n\n    k = k % numsSize;   // handle k > size\n    \n    reverse(nums, 0, numsSize - 1);      // reverse whole array\n    reverse(nums, 0, k - 1);             // reverse first k elements\n    reverse(nums, k, numsSize - 1);      // reverse remaining elements\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  }
]

    }
  },
  {
    "day": 17,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Find Maximum and Minimum Element",
      "description": "Problem: Write a program to find the maximum and minimum values present in a given array of integers.\n\nInput:\n- First line: integer n\n- Second line: n integers\n\nOutput:\n- Print the maximum and minimum elements\n\nExample:\nInput:\n6\n3 5 1 9 2 8\n\nOutput:\nMax: 9\nMin: 1"
    },
    "question2": {
      "name": "Maximum Subarray",
      "link": "https://leetcode.com/problems/maximum-subarray/",
      "difficulty": "Medium"
    },
    "topics": [
      "Kadane",
      "DP Intro"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Find max and min in array:\n\n1. Initialize max and min to first element\n2. Iterate through remaining elements\n3. Update max if current > max\n4. Update min if current < min\n\nKey Points:\n- Single pass through array\n- Can optimize with pairs comparison\n- Handle empty array edge case",
          "code": "#include &lt;stdio.h&gt;\n#include <limits.h>\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    int max = arr[0];\n    int min = arr[0];\n    \n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) max = arr[i];\n        if (arr[i] < min) min = arr[i];\n    }\n    \n    printf(\"Max: %d\\n\", max);\n    printf(\"Min: %d\\n\", min);\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
  {
    "type": "video",
    "label": "Maximum Subarray - Video Solution",
    "link": "https://www.youtube.com/watch?v=5WZl3MMT0Eg"
  },
  {
    "type": "tutorial",
    "explanation": "Find maximum sum contiguous subarray (Kadane's Algorithm).\n\nApproach:\n1. Keep track of current sum and max sum\n2. Add current element to current sum\n3. If current sum < 0, reset to current element\n4. Update max sum at each step\n\nKey Points:\n- Dynamic programming approach\n- Linear time solution\n- Handle all negative numbers case",
    "code": "int maxSubArray(int* nums, int numsSize) {\n    int maxSum = nums[0];\n    int currSum = nums[0];\n\n    for (int i = 1; i < numsSize; i++) {\n        if (currSum < 0)\n            currSum = nums[i];\n        else\n            currSum += nums[i];\n\n        if (currSum > maxSum)\n            maxSum = currSum;\n    }\n\n    return maxSum;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  }
]

    }
  },
  {
    "day": 18,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Rotate Array by K Positions",
      "description": "Problem: Given an array of integers, rotate the array to the right by k positions.\n\nInput:\n- First line: integer n\n- Second line: n integers\n- Third line: integer k\n\nOutput:\n- Print the rotated array\n\nExample:\nInput:\n5\n1 2 3 4 5\n2\n\nOutput:\n4 5 1 2 3"
    },
    "question2": {
      "name": "Product of Array Except Self",
      "link": "https://leetcode.com/problems/product-of-array-except-self/",
      "difficulty": "Medium"
    },
    "topics": [
      "Prefix Suffix",
      "Array"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Rotate array right by k positions using reversal:\n\n1. Normalize k: k = k % n\n2. Reverse entire array\n3. Reverse first k elements\n4. Reverse remaining n-k elements\n\nKey Points:\n- In-place rotation\n- Handle k > n\n- Three reverses achieve rotation",
          "code": "#include &lt;stdio.h&gt;\n\nvoid reverse(int arr[], int start, int end) {\n    while (start < end) {\n        int temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n\nint main() {\n    int n, k;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    scanf(\"%d\", &k);\n    \n    k = k % n;\n    \n    reverse(arr, 0, n - 1);\n    reverse(arr, 0, k - 1);\n    reverse(arr, k, n - 1);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
  {
    "type": "video",
    "label": "Product of Array Except Self - Video Solution",
    "link": "https://www.youtube.com/watch?v=bNvIQI2wAjk"
  },
  {
    "type": "tutorial",
    "explanation": "Calculate product of all elements except self without division.\n\nApproach:\n1. Calculate prefix products (product of all elements before i)\n2. Calculate suffix products (product of all elements after i)\n3. result[i] = prefix[i] * suffix[i]\n\nOptimized: Use result array to store prefix, then multiply by suffix in reverse\n\nKey Points:\n- Cannot use division\n- O(n) time, O(1) extra space (output doesn't count)\n- Two passes through array",
    "code": "int* productExceptSelf(int* nums, int numsSize, int* returnSize) {\n    int* answer = (int*)malloc(numsSize * sizeof(int));\n    \n    *returnSize = numsSize;\n\n    // Step 1: Prefix products\n    answer[0] = 1;\n    for (int i = 1; i < numsSize; i++) {\n        answer[i] = answer[i - 1] * nums[i - 1];\n    }\n\n    // Step 2: Suffix products\n    int suffix = 1;\n    for (int i = numsSize - 1; i >= 0; i--) {\n        answer[i] = answer[i] * suffix;\n        suffix *= nums[i];\n    }\n\n    return answer;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  }
]

    }
  },
  {
    "day": 19,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Pair Sum Closest to Zero",
      "description": "Problem: Given an array of integers, find two elements whose sum is closest to zero.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n\nOutput:\n- Print the pair of elements whose sum is closest to zero\n\nExample:\nInput:\n5\n1 60 -10 70 -80\n\nOutput:\n-10 1\n\nExplanation: Among all possible pairs, the sum of -10 and 1 is -9, which is the closest to zero compared to other pairs."
    },
    "question2": {
      "name": "Maximum Sum Circular Subarray",
      "link": "https://leetcode.com/problems/maximum-sum-circular-subarray/description/",
      "difficulty": "Medium"
    },
    "topics": [
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Find pair with sum closest to zero using two pointers:\n\n1. Sort the array\n2. Use two pointers: left at start, right at end\n3. Calculate sum, update minimum if closer to zero\n4. Move pointers based on sum (if negative, move left; if positive, move right)\n\nKey Points:\n- Sorting enables two-pointer approach\n- Track minimum absolute sum\n- O(n log n) due to sorting",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include <limits.h>\n\nint compare(const void* a, const void* b) {\n    return ((int)a - (int)b);\n}\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    qsort(arr, n, sizeof(int), compare);\n    \n    int left = 0, right = n - 1;\n    int minSum = INT_MAX;\n    int resLeft = 0, resRight = 0;\n    \n    while (left < right) {\n        int sum = arr[left] + arr[right];\n        \n        if (abs(sum) < abs(minSum)) {\n            minSum = sum;\n            resLeft = arr[left];\n            resRight = arr[right];\n        }\n        \n        if (sum < 0) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    printf(\"%d %d\\n\", resLeft, resRight);\n    return 0;\n}",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Maximum Sum Circular Subarray - Video Solution",
          "link": "https://www.youtube.com/watch?v=fxT9KjakYPM"
        },
        {
          "type": "tutorial",
          "explanation": "Maximum Sum Circular Subarray using Kadane’s Algorithm.\n\nApproach:\n1. Use Kadane’s algorithm to find maximum subarray sum (non-circular).\n2. Use modified Kadane’s to find minimum subarray sum.\n3. Calculate total array sum.\n4. Answer = max(maxSub, totalSum - minSub).\n5. If all elements are negative (totalSum == minSub), return maxSub.",
          "code": "int maxSubarraySumCircular(int* nums, int numsSize) {\n    int totalSum = 0;\n    int maxSub = nums[0], currentMax = nums[0];\n    int minSub = nums[0], currentMin = nums[0];\n\n    for (int i = 0; i < numsSize; i++) {\n        totalSum += nums[i];\n        if (i > 0) {\n            currentMax = (nums[i] > currentMax + nums[i]) ? nums[i] : currentMax + nums[i];\n            maxSub = (maxSub > currentMax) ? maxSub : currentMax;\n\n            currentMin = (nums[i] < currentMin + nums[i]) ? nums[i] : currentMin + nums[i];\n            minSub = (minSub < currentMin) ? minSub : currentMin;\n        }\n    }\n\n    if (totalSum == minSub) return maxSub;\n\n    int circularMax = totalSum - minSub;\n    return (maxSub > circularMax) ? maxSub : circularMax;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 20,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Count Subarrays with Sum Zero",
      "description": "Problem: Given an array of integers, count the number of subarrays whose sum is equal to zero.\n\nInput:\n- First line: integer n\n- Second line: n integers\n\nOutput:\n- Print the count of subarrays having sum zero\n\nExample:\nInput:\n6\n1 -1 2 -2 3 -3\n\nOutput:\n6\n\nExplanation: A subarray is a continuous part of the array. For the input array 1 -1 2 -2 3 -3, the following subarrays have sum zero: [1, -1], [2, -2], [3, -3], [1, -1, 2, -2], [2, -2, 3, -3], and [1, -1, 2, -2, 3, -3]. Since there are 6 such subarrays, the output is 6."
    },
    "question2": {
      "name": "3Sum",
      "link": "https://leetcode.com/problems/3sum/",
      "difficulty": "Medium"
    },
    "topics": [
      "Sorting",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Count subarrays with sum zero using hash map:\n\n1. Use prefix sum approach\n2. Store cumulative sums in hash map with their frequencies\n3. If same prefix sum appears twice, subarrays between them have sum 0\n4. Count = frequency * (frequency - 1) / 2 for each sum\n\nKey Points:\n- Prefix sum concept\n- Hash map to track sums\n- Combination formula for counting",
          "code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    int count = 0;\n    \n    // Brute force: check all subarrays\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = i; j < n; j++) {\n            sum += arr[j];\n            if (sum == 0) {\n                count++;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", count);\n    return 0;\n}",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
  {
    "type": "video",
    "label": "3Sum - Video Solution",
    "link": "https://www.youtube.com/watch?v=jzZsG8n2R9A"
  },
  {
    "type": "tutorial",
    "explanation": "Find all unique triplets that sum to zero.\n\nApproach:\n1. Sort the array\n2. Fix first element, use two pointers for remaining\n3. Skip duplicates to avoid duplicate triplets\n4. Adjust pointers based on sum\n\nKey Points:\n- Sort first for two-pointer technique\n- Handle duplicates carefully\n- O(n²) time complexity",
    "code": "#include &lt;stdlib.h&gt\n\n// Comparator for qsort\nint compare(const void* a, const void* b) {\n    return ((int)a - (int)b);\n}\n\nint** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    // Sort the array\n    qsort(nums, numsSize, sizeof(int), compare);\n\n    // Allocate maximum possible space\n    int capacity = 10000;\n    int** result = (int*)malloc(capacity * sizeof(int));\n    returnColumnSizes = (int)malloc(capacity * sizeof(int));\n\n    returnSize = 0;\n\n    for (int i = 0; i < numsSize - 2; i++) {\n        // Skip duplicate first elements\n        if (i > 0 && nums[i] == nums[i - 1])\n            continue;\n\n        int left = i + 1;\n        int right = numsSize - 1;\n\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n\n            if (sum == 0) {\n                // Store the triplet\n                result[*returnSize] = (int)malloc(3 * sizeof(int));\n                result[*returnSize][0] = nums[i];\n                result[*returnSize][1] = nums[left];\n                result[*returnSize][2] = nums[right];\n\n                (*returnColumnSizes)[*returnSize] = 3;\n                (*returnSize)++;\n\n                // Skip duplicates\n                while (left < right && nums[left] == nums[left + 1]) left++;\n                while (left < right && nums[right] == nums[right - 1]) right--;\n\n                left++;\n                right--;\n            }\n            else if (sum < 0) {\n                left++;\n            }\n            else {\n                right--;\n            }\n        }\n    }\n\n    return result;\n}",
    "timeComplexity": "O(n²)",
    "spaceComplexity": "O(1)"
  }
]

    }
  },
    {
    "day": 21,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Create and Traverse Singly Linked List",
      "description": "Problem: Create and Traverse Singly Linked List\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n\nOutput:\n- Print the result\n\nExample:\nInput:\n5\n10 20 30 40 50\n\nOutput:\n10 20 30 40 50"
    },
    "question2": {
      "name": "Middle of the Linked List",
      "link": "https://leetcode.com/problems/middle-of-the-linked-list/",
      "difficulty": "Easy"
    },
    "topics": [
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution for Create and Traverse Singly Linked List:\n\n1. Create linked list nodes\n2. Perform required operations\n3. Output the result\n\nKey Points:\n- Use dynamic memory allocation\n- Handle edge cases\n- Free memory after use",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d\", head->data);\n        if (head->next != NULL) printf(\" \");\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n, value;\n    scanf(\"%d\", &n);\n    \n    struct Node* head = NULL;\n    struct Node* tail = NULL;\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &value);\n        struct Node* newNode = createNode(value);\n        if (head == NULL) {\n            head = tail = newNode;\n        } else {\n            tail->next = newNode;\n            tail = newNode;\n        }\n    }\n    \n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Middle of the Linked List Video",
          "link": "https://www.youtube.com/watch?v=nzaHG0dme4g"
        },
        {
          "type": "tutorial",
          "explanation": "Find the middle of a singly linked list using the slow and fast pointer technique.\n\nApproach:\n1. Use two pointers: slow and fast.\n2. Move slow by one step and fast by two steps.\n3. When fast reaches the end, slow will be at the middle.",
          "code": "struct ListNode {\n    int val;\n    struct ListNode* next;\n};\n\nstruct ListNode* middleNode(struct ListNode* head) {\n    struct ListNode* slow = head;\n    struct ListNode* fast = head;\n\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    return slow; // Middle node\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 22,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Count Nodes in Linked List",
      "description": "Problem: Count Nodes in Linked List\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n\nOutput:\n- Print the result\n\nExample:\nInput:\n5\n10 20 30 40 50\n\nOutput:\n10 20 30 40 50"
    },
    "question2": {
      "name": "Reverse Linked List",
      "link": "https://leetcode.com/problems/reverse-linked-list/",
      "difficulty": "Easy"
    },
    "topics": [
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution for Count Nodes in Linked List:\n\n1. Create linked list nodes\n2. Perform required operations\n3. Output the result\n\nKey Points:\n- Use dynamic memory allocation\n- Handle edge cases\n- Free memory after use",
          "code": "#include &lt;stdio.h&gt;\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nint countNodes(struct Node* head) {\n    int count = 0;\n    while (head != NULL) {\n        count++;\n        head = head->next;\n    }\n    return count;\n}\n\nint main() {\n    int n, value;\n    scanf(\"%d\", &n);\n    \n    struct Node* head = NULL;\n    struct Node* tail = NULL;\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &value);\n        struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n        newNode->data = value;\n        newNode->next = NULL;\n        \n        if (head == NULL) {\n            head = tail = newNode;\n        } else {\n            tail->next = newNode;\n            tail = newNode;\n        }\n    }\n    \n    printf(\"%d\\n\", countNodes(head));\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Reverse Linked List Video",
          "link": "https://www.youtube.com/watch?v=G0_I-ZF0S38"
        },
        {
          "type": "tutorial",
          "explanation": "Reverse a singly linked list using an iterative approach.\n\nApproach:\n1. Use three pointers: prev, curr, and next.\n2. Reverse the link of the current node.\n3. Move pointers forward until the list is reversed.",
          "code": "struct ListNode {\n    int val;\n    struct ListNode* next;\n};\n\nstruct ListNode* reverseList(struct ListNode* head) {\n    struct ListNode* prev = NULL;\n    struct ListNode* curr = head;\n    struct ListNode* next = NULL;\n\n    while (curr != NULL) {\n        next = curr->next;   // Store next node\n        curr->next = prev;   // Reverse link\n        prev = curr;         // Move prev forward\n        curr = next;         // Move curr forward\n    }\n\n    return prev; // New head of reversed list\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 23,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Merge Two Sorted Linked Lists",
      "description": "Problem: Merge Two Sorted Linked Lists - Implement using linked list with dynamic memory allocation.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers (first list)\n- Third line: integer m\n- Fourth line: m space-separated integers (second list)\n\nOutput:\n- Print the merged linked list elements, space-separated\n\nExample:\nInput:\n5\n10 20 30 40 50\n4\n15 25 35 45\n\nOutput:\n10 15 20 25 30 35 40 45 50\n\nExplanation:\nCompare nodes of both lists, append smaller to result, continue until all nodes are merged."
    },
    "question2": {
      "name": "List Cycle Detection",
      "link": "https://leetcode.com/problems/linked-list-cycle/description/s",
      "difficulty": "Easy"
    },
    "topics": [
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Merge two sorted linked lists:\n\n1. Use dummy node to simplify edge cases\n2. Compare nodes from both lists\n3. Attach smaller node to result\n4. Move pointer of list from which node was taken\n5. Attach remaining nodes when one list is exhausted\n\nKey Points:\n- Maintain sorted order\n- Use dummy node technique\n- Handle unequal length lists",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nstruct Node* mergeSortedLists(struct Node* l1, struct Node* l2) {\n    struct Node dummy;\n    struct Node* tail = &dummy;\n    dummy.next = NULL;\n    \n    while (l1 != NULL && l2 != NULL) {\n        if (l1->data <= l2->data) {\n            tail->next = l1;\n            l1 = l1->next;\n        } else {\n            tail->next = l2;\n            l2 = l2->next;\n        }\n        tail = tail->next;\n    }\n    \n    tail->next = (l1 != NULL) ? l1 : l2;\n    return dummy.next;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d\", head->data);\n        if (head->next != NULL) printf(\" \");\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n, m, value;\n    struct Node *list1 = NULL, *list2 = NULL;\n    struct Node *tail1 = NULL, *tail2 = NULL;\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &value);\n        struct Node* newNode = createNode(value);\n        if (list1 == NULL) {\n            list1 = tail1 = newNode;\n        } else {\n            tail1->next = newNode;\n            tail1 = newNode;\n        }\n    }\n    \n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &value);\n        struct Node* newNode = createNode(value);\n        if (list2 == NULL) {\n            list2 = tail2 = newNode;\n        } else {\n            tail2->next = newNode;\n            tail2 = newNode;\n        }\n    }\n    \n    struct Node* merged = mergeSortedLists(list1, list2);\n    printList(merged);\n    return 0;\n}",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Linked List Cycle - Video Solution",
          "link": "https://www.youtube.com/watch?v=gBTe7lFR3vc"
        },
        {
          "type": "tutorial",
          "explanation": "Detect cycle using Floyd's algorithm (slow-fast pointers):\n\n1. Use two pointers: slow moves 1 step, fast moves 2 steps\n2. If fast meets slow, cycle exists\n3. If fast reaches NULL, no cycle\n\nKey Points:\n- Also called tortoise and hare algorithm\n- O(n) time, O(1) space\n- Fast pointer will catch slow if cycle exists",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include <stdbool.h>\n\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\n\nbool hasCycle(struct ListNode *head) {\n    if (head == NULL || head->next == NULL) {\n        return false;\n    }\n    \n    struct ListNode* slow = head;\n    struct ListNode* fast = head;\n    \n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        \n        if (slow == fast) {\n            return true;\n        }\n    }\n    \n    return false;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 24,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Delete First Occurrence of a Key",
      "description": "Problem: Delete First Occurrence of a Key - Implement using linked list with dynamic memory allocation.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n- Third line: integer key\n\nOutput:\n- Print the linked list elements after deletion, space-separated\n\nExample:\nInput:\n5\n10 20 30 40 50\n30\n\nOutput:\n10 20 40 50\n\nExplanation:\nTraverse list, find first node with key, remove it by adjusting previous node's next pointer."
    },
    "question2": {
      "name": "Remove Linked List Elements",
      "link": "https://leetcode.com/problems/remove-linked-list-elements/",
      "difficulty": "Easy"
    },
    "topics": [
      "Deletion",
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Delete first occurrence of key in linked list:\n\n1. Handle special case: key is at head\n2. Use two pointers: prev and current\n3. Traverse until finding key or reaching end\n4. If found, adjust prev->next to skip node\n5. Free deleted node memory\n\nKey Points:\n- Check if head contains key\n- Maintain prev pointer for deletion\n- Free memory to avoid leaks",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nstruct Node* deleteKey(struct Node* head, int key) {\n    // Handle head deletion\n    if (head != NULL && head->data == key) {\n        struct Node* temp = head;\n        head = head->next;\n        free(temp);\n        return head;\n    }\n    \n    struct Node* prev = NULL;\n    struct Node* current = head;\n    \n    while (current != NULL && current->data != key) {\n        prev = current;\n        current = current->next;\n    }\n    \n    if (current != NULL) {\n        prev->next = current->next;\n        free(current);\n    }\n    \n    return head;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d\", head->data);\n        if (head->next != NULL) printf(\" \");\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n, value, key;\n    struct Node* head = NULL;\n    struct Node* tail = NULL;\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &value);\n        struct Node* newNode = createNode(value);\n        if (head == NULL) {\n            head = tail = newNode;\n        } else {\n            tail->next = newNode;\n            tail = newNode;\n        }\n    }\n    \n    scanf(\"%d\", &key);\n    head = deleteKey(head, key);\n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Remove Linked List Elements - Video Solution",
          "link": "https://www.youtube.com/watch?v=JI71sxtHTng"
        },
        {
          "type": "tutorial",
          "explanation": "Remove all nodes with given value:\n\n1. Use dummy node to handle head deletion\n2. Traverse list with prev and current pointers\n3. If current->val == val, skip node\n4. Otherwise, move prev forward\n\nKey Points:\n- Remove ALL occurrences (not just first)\n- Dummy node simplifies code\n- Don't forget to free memory in C",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\n\nstruct ListNode* removeElements(struct ListNode* head, int val) {\n    struct ListNode dummy;\n    dummy.next = head;\n    struct ListNode* prev = &dummy;\n    struct ListNode* current = head;\n    \n    while (current != NULL) {\n        if (current->val == val) {\n            prev->next = current->next;\n            struct ListNode* temp = current;\n            current = current->next;\n            free(temp);\n        } else {\n            prev = current;\n            current = current->next;\n        }\n    }\n    \n    return dummy.next;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 25,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Count Occurrences of an Element in Linked List",
      "description": "Problem: Count Occurrences of an Element in Linked List - Implement using linked list with dynamic memory allocation.\n\nInput:\n- First line: integer n (number of nodes)\n- Second line: n space-separated integers (linked list elements)\n- Third line: integer key (element to be counted)\n\nOutput:\n- Print the number of times the key appears in the linked list\n\nExample:\nInput:\n6\n10 20 30 20 40 20\n20\n\nOutput:\n3\n\nExplanation:\nTraverse the linked list from head to end. Each time a node's data matches the given key, increment a counter. After traversal, print the final count."
    },
    "question2": {
      "name": "Linked List Cycle II",
      "link": "https://leetcode.com/problems/linked-list-cycle-ii/description/",
      "difficulty": "Easy"
    },
    "topics": [
      "Cycle Detection",
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Count occurrences of key in linked list:\n\n1. Initialize counter to 0\n2. Traverse from head to end\n3. For each node, if data == key, increment counter\n4. Return final count\n\nKey Points:\n- Simple linear traversal\n- Count all occurrences, not just first\n- O(n) time complexity",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint countOccurrences(struct Node* head, int key) {\n    int count = 0;\n    struct Node* current = head;\n    \n    while (current != NULL) {\n        if (current->data == key) {\n            count++;\n        }\n        current = current->next;\n    }\n    \n    return count;\n}\n\nint main() {\n    int n, value, key;\n    struct Node* head = NULL;\n    struct Node* tail = NULL;\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &value);\n        struct Node* newNode = createNode(value);\n        if (head == NULL) {\n            head = tail = newNode;\n        } else {\n            tail->next = newNode;\n            tail = newNode;\n        }\n    }\n    \n    scanf(\"%d\", &key);\n    printf(\"%d\\n\", countOccurrences(head, key));\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Linked List Cycle II - Video Solution",
          "link": "https://www.youtube.com/watch?v=gWv_D_iBQBk"
        },
        {
          "type": "tutorial",
          "explanation": "Detect the start of a cycle in a linked list using Floyd’s Cycle Detection Algorithm.\n\nApproach:\n1. Use two pointers: slow (1 step) and fast (2 steps).\n2. If slow and fast meet, a cycle exists.\n3. Move one pointer to head and advance both by one step.\n4. The node where they meet again is the start of the cycle.",
          "code": "struct ListNode {\n    int val;\n    struct ListNode* next;\n};\n\nstruct ListNode* detectCycle(struct ListNode* head) {\n    struct ListNode* slow = head;\n    struct ListNode* fast = head;\n\n    // Step 1: Detect cycle\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) break;\n    }\n\n    // No cycle\n    if (fast == NULL || fast->next == NULL) return NULL;\n\n    // Step 2: Find cycle start\n    while (head != slow) {\n        head = head->next;\n        slow = slow->next;\n    }\n\n    return head; // Start of the cycle\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 26,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Doubly Linked List Insertion and Traversal",
      "description": "Problem: Doubly Linked List Insertion and Traversal - Implement using linked list with dynamic memory allocation.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n\nOutput:\n- Print the linked list elements in forward order, space-separated\n\nExample:\nInput:\n5\n10 20 30 40 50\n\nOutput:\n10 20 30 40 50\n\nExplanation:\nEach node has data, next, prev. Insert nodes sequentially, traverse from head using next pointer."
    },
    "question2": {
      "name": "Design Linked List",
      "link": "https://leetcode.com/problems/design-linked-list/",
      "difficulty": "Medium"
    },
    "topics": [
      "Doubly Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Create doubly linked list with insertion and traversal:\n\n1. Define node with data, next, and prev pointers\n2. For insertion: set new node's prev to tail\n3. Set tail's next to new node\n4. Update tail to new node\n5. Traverse using next pointers (or prev for backward)\n\nKey Points:\n- Each node has two pointers\n- Can traverse in both directions\n- More memory than singly linked list",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    newNode->prev = NULL;\n    return newNode;\n}\n\nvoid printForward(struct Node* head) {\n    struct Node* current = head;\n    while (current != NULL) {\n        printf(\"%d\", current->data);\n        if (current->next != NULL) printf(\" \");\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n, value;\n    struct Node* head = NULL;\n    struct Node* tail = NULL;\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &value);\n        struct Node* newNode = createNode(value);\n        \n        if (head == NULL) {\n            head = tail = newNode;\n        } else {\n            tail->next = newNode;\n            newNode->prev = tail;\n            tail = newNode;\n        }\n    }\n    \n    printForward(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Design Linked List - Video Solution",
          "link": "https://www.youtube.com/watch?v=Wf4QhpdVFQo"
        },
        {
          "type": "tutorial",
          "explanation": "Design your own linked list with operations:\n\n1. Implement get(index), addAtHead(val), addAtTail(val)\n2. Implement addAtIndex(index, val), deleteAtIndex(index)\n3. Use singly linked list or doubly linked list\n\nKey Points:\n- Choose between singly/doubly linked list\n- Handle edge cases (empty list, invalid index)\n- Maintain size variable for efficiency",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct Node {\n    int val;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    Node* head;\n    int size;\n} MyLinkedList;\n\nMyLinkedList* myLinkedListCreate() {\n    MyLinkedList* obj = (MyLinkedList*)malloc(sizeof(MyLinkedList));\n    obj->head = NULL;\n    obj->size = 0;\n    return obj;\n}\n\nint myLinkedListGet(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) return -1;\n    \n    Node* curr = obj->head;\n    for (int i = 0; i < index; i++) {\n        curr = curr->next;\n    }\n    return curr->val;\n}\n\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->val = val;\n    newNode->next = obj->head;\n    obj->head = newNode;\n    obj->size++;\n}\n\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->val = val;\n    newNode->next = NULL;\n    \n    if (obj->head == NULL) {\n        obj->head = newNode;\n    } else {\n        Node* curr = obj->head;\n        while (curr->next != NULL) {\n            curr = curr->next;\n        }\n        curr->next = newNode;\n    }\n    obj->size++;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 27,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Find Intersection Point of Two Linked Lists",
      "description": "Problem: Find Intersection Point of Two Linked Lists - Implement using linked list with dynamic memory allocation.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers (first list)\n- Third line: integer m\n- Fourth line: m space-separated integers (second list)\n\nOutput:\n- Print value of intersection node or 'No Intersection'\n\nExample:\nInput:\n5\n10 20 30 40 50\n4\n15 25 30 40 50\n\nOutput:\n30\n\nExplanation:\nCalculate lengths, advance pointer in longer list, traverse both simultaneously. First common node is intersection."
    },
    "question2": {
      "name": "Remove Cycle in Linked List",
      "link": "https://www.geeksforgeeks.org/problems/remove-loop-in-linked-list/1",
      "difficulty": "Easy"
    },
    "topics": [
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Find intersection of two linked lists:\n\n1. Calculate length of both lists\n2. Advance pointer in longer list by difference\n3. Move both pointers together until they meet\n4. Meeting point is intersection (or NULL if no intersection)\n\nKey Points:\n- Align both lists by advancing longer one\n- Compare nodes, not values\n- O(m + n) time, O(1) space",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nint getLength(struct Node* head) {\n    int len = 0;\n    while (head != NULL) {\n        len++;\n        head = head->next;\n    }\n    return len;\n}\n\nstruct Node* findIntersection(struct Node* head1, struct Node* head2) {\n    int len1 = getLength(head1);\n    int len2 = getLength(head2);\n    \n    struct Node* ptr1 = head1;\n    struct Node* ptr2 = head2;\n    \n    // Advance longer list\n    if (len1 > len2) {\n        for (int i = 0; i < len1 - len2; i++) {\n            ptr1 = ptr1->next;\n        }\n    } else {\n        for (int i = 0; i < len2 - len1; i++) {\n            ptr2 = ptr2->next;\n        }\n    }\n    \n    // Find intersection\n    while (ptr1 != NULL && ptr2 != NULL) {\n        if (ptr1->data == ptr2->data) {\n            return ptr1;\n        }\n        ptr1 = ptr1->next;\n        ptr2 = ptr2->next;\n    }\n    \n    return NULL;\n}",
          "timeComplexity": "O(m + n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Remove Loop in Linked List - Video Solution",
          "link": "https://www.youtube.com/watch?v=qsPoOVAHV_I"
        },
        {
          "type": "tutorial",
          "explanation": "Remove cycle from linked list:\n\n1. Detect cycle using Floyd's algorithm\n2. Find start of cycle\n3. Find node just before start\n4. Set its next to NULL\n\nKey Points:\n- First detect if cycle exists\n- Move one pointer to head after detection\n- Move both one step until they meet (cycle start)\n- Remove by setting next to NULL",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include <stdbool.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nvoid removeLoop(struct Node* head) {\n    if (head == NULL || head->next == NULL) return;\n    \n    struct Node* slow = head;\n    struct Node* fast = head;\n    \n    // Detect cycle\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) break;\n    }\n    \n    if (slow != fast) return; // No cycle\n    \n    // Find start of cycle\n    slow = head;\n    while (slow->next != fast->next) {\n        slow = slow->next;\n        fast = fast->next;\n    }\n    \n    // Remove cycle\n    fast->next = NULL;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 28,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Circular Linked List Creation and Traversal",
      "description": "Problem: Circular Linked List Creation and Traversal - Implement using linked list with dynamic memory allocation.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n\nOutput:\n- Print the circular linked list elements starting from head, space-separated\n\nExample:\nInput:\n5\n10 20 30 40 50\n\nOutput:\n10 20 30 40 50\n\nExplanation:\nLast node's next points to head. Traverse from head until returning to head to avoid infinite loop."
    },
    "question2": {
      "name": "Palindrome Linked List",
      "link": "https://leetcode.com/problems/palindrome-linked-list/description/",
      "difficulty": "Medium"
    },
    "topics": [
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Create and traverse circular linked list:\n\n1. Create nodes and link them\n2. Set last node's next to head (makes it circular)\n3. For traversal: start from head, stop when reaching head again\n4. Use counter or do-while to print exactly n nodes\n\nKey Points:\n- Last node points back to head\n- Avoid infinite loop in traversal\n- Use counter to print exact number of nodes",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid printCircular(struct Node* head, int n) {\n    if (head == NULL) return;\n    \n    struct Node* current = head;\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", current->data);\n        if (i < n - 1) printf(\" \");\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n, value;\n    struct Node* head = NULL;\n    struct Node* tail = NULL;\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &value);\n        struct Node* newNode = createNode(value);\n        \n        if (head == NULL) {\n            head = tail = newNode;\n        } else {\n            tail->next = newNode;\n            tail = newNode;\n        }\n    }\n    \n    // Make it circular\n    if (tail != NULL) {\n        tail->next = head;\n    }\n    \n    printCircular(head, n);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Palindrome Linked List - Video Solution",
          "link": "https://www.youtube.com/watch?v=yOzXms1J6Nk"
        },
        {
          "type": "tutorial",
          "explanation": "Check if linked list is palindrome:\n\n1. Find middle using slow-fast pointers\n2. Reverse second half\n3. Compare first half with reversed second half\n4. Restore list (optional)\n\nKey Points:\n- O(n) time, O(1) space solution\n- Find middle, reverse second half\n- Compare values node by node",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include <stdbool.h>\n\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\n\nstruct ListNode* reverseList(struct ListNode* head) {\n    struct ListNode* prev = NULL;\n    while (head != NULL) {\n        struct ListNode* next = head->next;\n        head->next = prev;\n        prev = head;\n        head = next;\n    }\n    return prev;\n}\n\nbool isPalindrome(struct ListNode* head) {\n    if (head == NULL || head->next == NULL) return true;\n    \n    // Find middle\n    struct ListNode *slow = head, *fast = head;\n    while (fast->next != NULL && fast->next->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    \n    // Reverse second half\n    struct ListNode* secondHalf = reverseList(slow->next);\n    \n    // Compare\n    struct ListNode* p1 = head;\n    struct ListNode* p2 = secondHalf;\n    bool result = true;\n    \n    while (p2 != NULL) {\n        if (p1->val != p2->val) {\n            result = false;\n            break;\n        }\n        p1 = p1->next;\n        p2 = p2->next;\n    }\n    \n    return result;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 29,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Rotate Linked List Right by k Places",
      "description": "Problem: Rotate Linked List Right by k Places - Implement using linked list with dynamic memory allocation.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n- Third line: integer k\n\nOutput:\n- Print the linked list elements after rotation, space-separated\n\nExample:\nInput:\n5\n10 20 30 40 50\n2\n\nOutput:\n40 50 10 20 30\n\nExplanation:\nConnect last node to head forming circular list. Traverse to (n-k)th node, set next to NULL, update head to (n-k+1)th node."
    },
    "question2": {
      "name": "Add Two Numbers",
      "link": "https://leetcode.com/problems/add-two-numbers/description/",
      "difficulty": "Medium"
    },
    "topics": [
      "Rotation",
      "Linked List"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Rotate linked list right by k positions:\n\n1. Find length of list\n2. Calculate effective rotation: k = k % length\n3. Find (length - k)th node\n4. Make it new tail, next node becomes new head\n5. Connect old tail to old head\n\nKey Points:\n- Handle k >= length using modulo\n- Make circular temporarily\n- Break at correct position",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nstruct Node* rotateRight(struct Node* head, int k) {\n    if (head == NULL || k == 0) return head;\n    \n    // Find length and last node\n    int length = 1;\n    struct Node* tail = head;\n    while (tail->next != NULL) {\n        tail = tail->next;\n        length++;\n    }\n    \n    k = k % length;\n    if (k == 0) return head;\n    \n    // Find new tail\n    struct Node* newTail = head;\n    for (int i = 0; i < length - k - 1; i++) {\n        newTail = newTail->next;\n    }\n    \n    struct Node* newHead = newTail->next;\n    newTail->next = NULL;\n    tail->next = head;\n    \n    return newHead;\n}\n\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d\", head->data);\n        if (head->next != NULL) printf(\" \");\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n, value, k;\n    struct Node* head = NULL;\n    struct Node* tail = NULL;\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &value);\n        struct Node* newNode = createNode(value);\n        if (head == NULL) {\n            head = tail = newNode;\n        } else {\n            tail->next = newNode;\n            tail = newNode;\n        }\n    }\n    \n    scanf(\"%d\", &k);\n    head = rotateRight(head, k);\n    printList(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Add Two Numbers - Video Solution",
          "link": "https://www.youtube.com/watch?v=wgFPrzTjm7s"
        },
        {
          "type": "tutorial",
          "explanation": "Add two numbers represented as linked lists:\n\n1. Numbers stored in reverse order\n2. Traverse both lists simultaneously\n3. Add values plus carry\n4. Create new node with sum % 10\n5. Update carry = sum / 10\n\nKey Points:\n- Handle different lengths\n- Don't forget final carry\n- Create new list for result",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\n\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    struct ListNode dummy;\n    struct ListNode* current = &dummy;\n    int carry = 0;\n    \n    while (l1 != NULL || l2 != NULL || carry != 0) {\n        int sum = carry;\n        \n        if (l1 != NULL) {\n            sum += l1->val;\n            l1 = l1->next;\n        }\n        \n        if (l2 != NULL) {\n            sum += l2->val;\n            l2 = l2->next;\n        }\n        \n        carry = sum / 10;\n        current->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n        current->next->val = sum % 10;\n        current->next->next = NULL;\n        current = current->next;\n    }\n    \n    return dummy.next;\n}",
          "timeComplexity": "O(max(m, n))",
          "spaceComplexity": "O(max(m, n))"
        }
      ]
    }
  },
  {
    "day": 30,
    "unit": "Unit II: Linked List",
    "question1": {
      "title": "Polynomial Using Linked List",
      "description": "Problem: Polynomial Using Linked List - Implement using linked list with dynamic memory allocation.\n\nInput:\n- First line: integer n (number of terms)\n- Next n lines: two integers (coefficient and exponent)\n\nOutput:\n- Print polynomial in standard form, e.g., 10x^4 + 20x^3 + 30x^2 + 40x + 50\n\nExample:\nInput:\n5\n10 4\n20 3\n30 2\n40 1\n50 0\n\nOutput:\n10x^4 + 20x^3 + 30x^2 + 40x + 50\n\nExplanation:\nEach node stores coefficient and exponent. Traverse nodes to print polynomial in decreasing exponent order."
    },
    "question2": {
      "name": "Add Two Numbers II",
      "link": "https://leetcode.com/problems/add-two-numbers-ii/",
      "difficulty": "Medium"
    },
    "topics": [
      "Polynomial LL",
      "Representation"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Represent polynomial using linked list:\n\n1. Each node contains coefficient and exponent\n2. Store terms in descending order of exponent\n3. For printing: handle special cases (first term, last term, x^1, x^0)\n4. Format: coefficient + \"x^\" + exponent\n\nKey Points:\n- Node has coeff and exp fields\n- Print with proper formatting (+, -, x^n)\n- Handle special cases for display",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Term {\n    int coeff;\n    int exp;\n    struct Term* next;\n};\n\nstruct Term* createTerm(int coeff, int exp) {\n    struct Term* newTerm = (struct Term*)malloc(sizeof(struct Term));\n    newTerm->coeff = coeff;\n    newTerm->exp = exp;\n    newTerm->next = NULL;\n    return newTerm;\n}\n\nvoid printPolynomial(struct Term* head) {\n    struct Term* current = head;\n    int first = 1;\n    \n    while (current != NULL) {\n        if (!first && current->coeff > 0) {\n            printf(\" + \");\n        } else if (current->coeff < 0) {\n            printf(\" - \");\n        }\n        \n        int absCoeff = abs(current->coeff);\n        \n        if (current->exp == 0) {\n            printf(\"%d\", absCoeff);\n        } else if (current->exp == 1) {\n            printf(\"%dx\", absCoeff);\n        } else {\n            printf(\"%dx^%d\", absCoeff, current->exp);\n        }\n        \n        first = 0;\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n, coeff, exp;\n    struct Term* head = NULL;\n    struct Term* tail = NULL;\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &coeff, &exp);\n        struct Term* newTerm = createTerm(coeff, exp);\n        \n        if (head == NULL) {\n            head = tail = newTerm;\n        } else {\n            tail->next = newTerm;\n            tail = newTerm;\n        }\n    }\n    \n    printPolynomial(head);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Add Two Numbers II - Video Solution",
          "link": "https://www.youtube.com/watch?v=Yc9buffV1G0"
        },
        {
          "type": "tutorial",
          "explanation": "Add two numbers in forward order:\n\n1. Reverse both lists or use stack\n2. Add from least significant digit\n3. Handle carry\n4. Reverse result or build in correct order\n\nKey Points:\n- Numbers in forward order (unlike Add Two Numbers I)\n- Can use stack or reverse lists\n- Don't modify input lists if possible",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\n\nstruct ListNode* reverseList(struct ListNode* head) {\n    struct ListNode* prev = NULL;\n    while (head != NULL) {\n        struct ListNode* next = head->next;\n        head->next = prev;\n        prev = head;\n        head = next;\n    }\n    return prev;\n}\n\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    // Reverse both lists\n    l1 = reverseList(l1);\n    l2 = reverseList(l2);\n    \n    struct ListNode dummy;\n    struct ListNode* current = &dummy;\n    int carry = 0;\n    \n    while (l1 != NULL || l2 != NULL || carry != 0) {\n        int sum = carry;\n        if (l1 != NULL) {\n            sum += l1->val;\n            l1 = l1->next;\n        }\n        if (l2 != NULL) {\n            sum += l2->val;\n            l2 = l2->next;\n        }\n        \n        carry = sum / 10;\n        current->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n        current->next->val = sum % 10;\n        current->next->next = NULL;\n        current = current->next;\n    }\n    \n    // Reverse result\n    return reverseList(dummy.next);\n}",
          "timeComplexity": "O(max(m, n))",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 31,
    "unit": "Unit III: Stack and Queue",
    "question1": {
      "title": "Stack Implementation using Array",
      "description": "Problem: Implement a stack data structure using an array with the following operations: push, pop, and display.\n\nInput:\n- First line: integer n (number of operations)\n- Next n lines: operation type and value (if applicable)\n  - 1 value: push value\n  - 2: pop\n  - 3: display\n\nOutput:\n- For display: print stack elements from top to bottom\n- For pop: print popped element or 'Stack Underflow'\n\nExample:\nInput:\n5\n1 10\n1 20\n3\n2\n3\n\nOutput:\n20 10\n20\n10"
    },
    "question2": {
      "name": "Valid Parentheses",
      "link": "https://leetcode.com/problems/valid-parentheses/",
      "difficulty": "Easy"
    },
    "topics": [
      "Stack"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Implement stack using array:\n\n1. Use array and top pointer (initially -1)\n2. Push: increment top, add element\n3. Pop: return element at top, decrement top\n4. Check overflow (top >= MAX-1) and underflow (top < 0)\n\nKey Points:\n- Top points to last inserted element\n- LIFO (Last In First Out) principle\n- Check bounds before operations",
          "code": "#include &lt;stdio.h&gt;\n#include <stdbool.h>\n\n#define MAX 100\n\nint stack[MAX];\nint top = -1;\n\nbool isEmpty() {\n    return top == -1;\n}\n\nbool isFull() {\n    return top == MAX - 1;\n}\n\nvoid push(int value) {\n    if (isFull()) {\n        printf(\"Stack Overflow\\n\");\n        return;\n    }\n    stack[++top] = value;\n}\n\nint pop() {\n    if (isEmpty()) {\n        printf(\"Stack Underflow\\n\");\n        return -1;\n    }\n    return stack[top--];\n}\n\nvoid display() {\n    if (isEmpty()) {\n        printf(\"Stack is empty\\n\");\n        return;\n    }\n    for (int i = top; i >= 0; i--) {\n        printf(\"%d\", stack[i]);\n        if (i > 0) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n, op, value;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &op);\n        if (op == 1) {\n            scanf(\"%d\", &value);\n            push(value);\n        } else if (op == 2) {\n            int popped = pop();\n            if (popped != -1) {\n                printf(\"%d\\n\", popped);\n            }\n        } else if (op == 3) {\n            display();\n        }\n    }\n    \n    return 0;\n}",
          "timeComplexity": "O(1) per operation",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Valid Parentheses - Video",
          "link": "https://www.youtube.com/watch?v=WTzjTskDFMg"
        },
        {
          "type": "tutorial",
          "explanation": "Check if parentheses are balanced using stack:\n\n1. For opening bracket: push to stack\n2. For closing bracket: check if matches top of stack\n3. If matches, pop; otherwise invalid\n4. At end, stack should be empty\n\nKey Points:\n- Use stack to match pairs\n- Check for corresponding opening bracket\n- Stack must be empty at end",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include <string.h>\n#include <stdbool.h>\n\nbool isValid(char* s) {\n    int len = strlen(s);\n    char stack[len];\n    int top = -1;\n    \n    for (int i = 0; i < len; i++) {\n        char c = s[i];\n        \n        if (c == '(' || c == '[' || c == '{') {\n            stack[++top] = c;\n        } else {\n            if (top == -1) return false;\n            \n            char last = stack[top--];\n            if ((c == ')' && last != '(') ||\n                (c == ']' && last != '[') ||\n                (c == '}' && last != '{')) {\n                return false;\n            }\n        }\n    }\n    \n    return top == -1;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ]
    }
  },
  {
    "day": 32,
    "unit": "Unit III: Stack and Queue",
    "question1": {
      "title": "Push and Pop in Stack",
      "description": "Problem: Implement push and pop operations on a stack and verify stack operations.\n\nInput:\n- First line: integer n\n- Second line: n integers to push\n- Third line: integer m (number of pops)\n\nOutput:\n- Print remaining stack elements from top to bottom\n\nExample:\nInput:\n5\n10 20 30 40 50\n2\n\nOutput:\n30 20 10"
    },
    "question2": {
      "name": "Min Stack",
      "link": "https://leetcode.com/problems/min-stack/",
      "difficulty": "Medium"
    },
    "topics": [
      "Stack Operations"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Stack push and pop operations:\n\n1. Push all elements onto stack\n2. Pop m elements\n3. Display remaining elements\n\nKey Points:\n- Maintain top pointer\n- Check underflow before pop\n- Display from top to bottom",
          "code": "#include &lt;stdio.h&gt;\n\n#define MAX 100\n\nint stack[MAX];\nint top = -1;\n\nvoid push(int value) {\n    if (top < MAX - 1) {\n        stack[++top] = value;\n    }\n}\n\nint pop() {\n    if (top >= 0) {\n        return stack[top--];\n    }\n    return -1;\n}\n\nint main() {\n    int n, m, value;\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &value);\n        push(value);\n    }\n    \n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++) {\n        pop();\n    }\n    \n    // Display remaining\n    for (int i = top; i >= 0; i--) {\n        printf(\"%d\", stack[i]);\n        if (i > 0) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Min Stack - Video",
          "link": "https://www.youtube.com/watch?v=qkLl7nAwDPo"
        },
        {
          "type": "tutorial",
          "explanation": "Design stack that supports getMin in O(1):\n\n1. Use two stacks: main stack and min stack\n2. Min stack keeps track of minimum at each level\n3. On push: update min stack\n4. On pop: pop from both stacks\n5. getMin: return top of min stack\n\nKey Points:\n- Parallel stacks approach\n- Min stack mirrors main stack\n- All operations in O(1)",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include <limits.h>\n\ntypedef struct {\n    int* stack;\n    int* minStack;\n    int top;\n    int capacity;\n} MinStack;\n\nMinStack* minStackCreate() {\n    MinStack* obj = (MinStack*)malloc(sizeof(MinStack));\n    obj->capacity = 10000;\n    obj->stack = (int*)malloc(obj->capacity * sizeof(int));\n    obj->minStack = (int*)malloc(obj->capacity * sizeof(int));\n    obj->top = -1;\n    return obj;\n}\n\nvoid minStackPush(MinStack* obj, int val) {\n    obj->stack[++obj->top] = val;\n    if (obj->top == 0) {\n        obj->minStack[obj->top] = val;\n    } else {\n        int currentMin = obj->minStack[obj->top - 1];\n        obj->minStack[obj->top] = val < currentMin ? val : currentMin;\n    }\n}\n\nvoid minStackPop(MinStack* obj) {\n    if (obj->top >= 0) {\n        obj->top--;\n    }\n}\n\nint minStackTop(MinStack* obj) {\n    return obj->stack[obj->top];\n}\n\nint minStackGetMin(MinStack* obj) {\n    return obj->minStack[obj->top];\n}",
          "timeComplexity": "O(1) all operations",
          "spaceComplexity": "O(n)"
        }
      ]
    }
  },
  {
    "day": 33,
    "unit": "Unit III: Stack and Queue",
    "question1": {
      "title": "Infix to Postfix Conversion",
      "description": "Problem: Convert an infix expression to postfix notation using stack.\n\nInput:\n- Single line: infix expression (operands are single characters)\n\nOutput:\n- Print the postfix expression\n\nExample:\nInput:\nA+B*C\n\nOutput:\nABC*+\n\nExplanation:\nOperator precedence: * > +\nUse stack to handle operator precedence and associativity"
    },
    "question2": {
      "name": "Evaluate Reverse Polish Notation",
      "link": "https://leetcode.com/problems/evaluate-reverse-polish-notation/",
      "difficulty": "Medium"
    },
    "topics": [
      "Expression Conversion"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Convert infix to postfix:\n\n1. Scan expression left to right\n2. Operand: add to output\n3. Operator: pop higher/equal precedence ops, then push\n4. '(': push to stack\n5. ')': pop until '('\n6. At end: pop all remaining operators\n\nKey Points:\n- Use precedence rules\n- Handle parentheses\n- Stack stores operators",
          "code": "#include &lt;stdio.h&gt;\n#include <string.h>\n#include <ctype.h>\n\n#define MAX 100\n\nchar stack[MAX];\nint top = -1;\n\nvoid push(char c) {\n    stack[++top] = c;\n}\n\nchar pop() {\n    return stack[top--];\n}\n\nchar peek() {\n    return stack[top];\n}\n\nint isEmpty() {\n    return top == -1;\n}\n\nint precedence(char op) {\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/') return 2;\n    if (op == '^') return 3;\n    return 0;\n}\n\nvoid infixToPostfix(char* infix) {\n    char postfix[MAX];\n    int k = 0;\n    \n    for (int i = 0; infix[i]; i++) {\n        char c = infix[i];\n        \n        if (isalnum(c)) {\n            postfix[k++] = c;\n        } else if (c == '(') {\n            push(c);\n        } else if (c == ')') {\n            while (!isEmpty() && peek() != '(') {\n                postfix[k++] = pop();\n            }\n            if (!isEmpty()) pop(); // Remove '('\n        } else {\n            while (!isEmpty() && precedence(peek()) >= precedence(c)) {\n                postfix[k++] = pop();\n            }\n            push(c);\n        }\n    }\n    \n    while (!isEmpty()) {\n        postfix[k++] = pop();\n    }\n    \n    postfix[k] = '\\0';\n    printf(\"%s\\n\", postfix);\n}\n\nint main() {\n    char infix[MAX];\n    scanf(\"%s\", infix);\n    infixToPostfix(infix);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Evaluate RPN - Video",
          "link": "https://www.youtube.com/watch?v=iu0082c4HDE"
        },
        {
          "type": "tutorial",
          "explanation": "Evaluate postfix expression:\n\n1. Scan tokens left to right\n2. If number: push to stack\n3. If operator: pop two operands, compute, push result\n4. Final result is top of stack\n\nKey Points:\n- Postfix has no parentheses\n- No precedence needed\n- Direct evaluation possible",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include <string.h>\n\nint evalRPN(char** tokens, int tokensSize) {\n    int stack[tokensSize];\n    int top = -1;\n    \n    for (int i = 0; i < tokensSize; i++) {\n        char* token = tokens[i];\n        \n        if (strcmp(token, \"+\") == 0) {\n            int b = stack[top--];\n            int a = stack[top--];\n            stack[++top] = a + b;\n        } else if (strcmp(token, \"-\") == 0) {\n            int b = stack[top--];\n            int a = stack[top--];\n            stack[++top] = a - b;\n        } else if (strcmp(token, \"*\") == 0) {\n            int b = stack[top--];\n            int a = stack[top--];\n            stack[++top] = a * b;\n        } else if (strcmp(token, \"/\") == 0) {\n            int b = stack[top--];\n            int a = stack[top--];\n            stack[++top] = a / b;\n        } else {\n            stack[++top] = atoi(token);\n        }\n    }\n    \n    return stack[top];\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ]
    }
  },
  {
    "day": 34,
    "unit": "Unit III: Stack and Queue",
    "question1": {
      "title": "Evaluate Postfix Expression",
      "description": "Problem: Evaluate Postfix Expression - Implement using linked list with dynamic memory allocation.\n\nInput:\n- Postfix expression with operands and operators\n\nOutput:\n- Print the integer result\n\nExample:\nInput:\n2 3 1 * + 9 -\n\nOutput:\n-4\n\nExplanation:\nUse stack to store operands, apply operators by popping operands, push result back. Final stack top is result."
    },
    "question2": {
      "name": "Basic Calculator II",
      "link": "https://leetcode.com/problems/basic-calculator-ii/",
      "difficulty": "Medium"
    },
    "topics": [
      "Stack and Queue"
    ],
    "solutions": {
      "question1": [
      {
        "type": "tutorial",
        "explanation": "Evaluate a postfix expression using a stack.\n\nApproach:\n1. Traverse the expression from left to right.\n2. Push operands onto the stack.\n3. On an operator, pop two operands, apply operation, and push result.\n4. Final stack value is the answer.",
        "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint applyOperator(int a, int b, char op) {\n    if (op == '+') return a + b;\n    if (op == '-') return a - b;\n    if (op == '*') return a * b;\n    if (op == '/') return a / b;\n    return 0;\n}\n\nint evaluatePostfix(char* exp) {\n    int stack[1000];\n    int top = -1;\n\n    for (int i = 0; exp[i] != '\\0'; i++) {\n        char ch = exp[i];\n\n        if (ch >= '0' && ch <= '9') {\n            stack[++top] = ch - '0';\n        } else {\n            int b = stack[top--];\n            int a = stack[top--];\n            stack[++top] = applyOperator(a, b, ch);\n        }\n    }\n\n    return stack[top];\n}\n\nint main() {\n    char exp[] = \"231*+9-\";\n    int result = evaluatePostfix(exp);\n    printf(\"Result: %d\", result);\n    return 0;\n}",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Basic Calculator II Video",
          "link": "https://www.youtube.com/watch?v=sfM4DjMfhw4"
        },
        {
          "type": "tutorial",
          "explanation": "Evaluate a mathematical expression containing +, -, *, / using a stack.\n\nApproach:\n- Use a stack to handle operator precedence.\n- + : push number\n- - : push negative number\n- * and / : compute immediately using stack top\n- Final result is the sum of stack elements.",
          "code": "#include &lt;ctype.h&gt\n\nint calculate(char* s) {\n    int stack[1000];\n    int top = -1;\n    char op = '+';\n    int i = 0;\n\n    while (s[i] != '\\0') {\n        if (s[i] == ' ') {\n            i++;\n        }\n        else if (s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/') {\n            op = s[i];\n            i++;\n        }\n        else {\n            int num = 0;\n            while (s[i] != '\\0' && isdigit(s[i])) {\n                num = num * 10 + (s[i] - '0');\n                i++;\n            }\n\n            if (op == '+') {\n                stack[++top] = num;\n            }\n            else if (op == '-') {\n                stack[++top] = -num;\n            }\n            else if (op == '*') {\n                stack[top] = stack[top] * num;\n            }\n            else if (op == '/') {\n                stack[top] = stack[top] / num; // truncates toward zero\n            }\n        }\n    }\n\n    int result = 0;\n    while (top >= 0) {\n        result += stack[top--];\n    }\n\n    return result;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ]
    }
  },
  {
    "day": 35,
    "unit": "Unit III: Stack and Queue",
    "question1": {
          "title": "Queue Using Array",
          "description": "Problem: Queue Using Array - Implement using linked list with dynamic memory allocation.\n\nInput:\n- First line: integer n (number of elements)\n- Second line: n space-separated integers\n\nOutput:\n- Print queue elements from front to rear, space-separated\n\nExample:\nInput:\n5\n10 20 30 40 50\n\nOutput:\n10 20 30 40 50\n\nExplanation:\nUse array and front/rear pointers. Enqueue inserts at rear, dequeue removes from front. Display from front to rear."
    },
    "question2": {
      "name": "Implement Queue using Stacks",
      "link": "https://leetcode.com/problems/implement-queue-using-stacks/",
      "difficulty": "Easy"
    },
    "topics": [
      "Stack and Queue"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Implement a Queue using an array in C.\n\nApproach:\n- Use an array with front and rear pointers.\n- Enqueue inserts at rear.\n- Dequeue removes from front.\n- Handle overflow and underflow conditions.",
          "code": "#include &lt;stdio.h&gt;\n#define MAX 100\n\nint queue[MAX];\nint front = -1, rear = -1;\n\nint isEmpty() {\n    return (front == -1 || front > rear);\n}\n\nint isFull() {\n    return (rear == MAX - 1);\n}\n\nvoid enqueue(int value) {\n    if (isFull()) {\n        printf(\"Queue Overflow\\n\");\n        return;\n    }\n    if (front == -1) front = 0;\n    queue[++rear] = value;\n}\n\nint dequeue() {\n    if (isEmpty()) {\n        printf(\"Queue Underflow\\n\");\n        return -1;\n    }\n    return queue[front++];\n}\n\nvoid display() {\n    if (isEmpty()) {\n        printf(\"Queue is Empty\\n\");\n        return;\n    }\n    for (int i = front; i <= rear; i++) {\n        printf(\"%d \", queue[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    enqueue(10);\n    enqueue(20);\n    enqueue(30);\n    display();\n    dequeue();\n    display();\n    return 0;\n}",
          "timeComplexity": "O(1) for enqueue and dequeue",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Implement Queue using Stacks Video",
          "link": "https://www.youtube.com/watch?v=eanwa3ht3YQ"
        },
        {
          "type": "tutorial",
          "explanation": "Implement a Queue using two stacks.\n\nApproach:\n- Use two stacks: stack1 (input) and stack2 (output).\n- Push operation inserts into stack1.\n- For pop/peek, move all elements from stack1 to stack2, access the front element, then move elements back.\n- This ensures FIFO behavior using LIFO stacks.",
          "code": "#include &lt;stdio.h&gt;\n#define MAX 100\n\nint stack1[MAX], stack2[MAX];\nint top1 = -1, top2 = -1;\n\nint isEmptyStack1() {\n    return top1 == -1;\n}\n\nvoid push(int x) {\n    stack1[++top1] = x;\n}\n\nint pop() {\n    // Move all elements to stack2\n    while (top1 != -1) {\n        stack2[++top2] = stack1[top1--];\n    }\n\n    int removed = stack2[top2--];\n\n    // Move back to stack1\n    while (top2 != -1) {\n        stack1[++top1] = stack2[top2--];\n    }\n\n    return removed;\n}\n\nint peek() {\n    while (top1 != -1) {\n        stack2[++top2] = stack1[top1--];\n    }\n\n    int front = stack2[top2];\n\n    while (top2 != -1) {\n        stack1[++top1] = stack2[top2--];\n    }\n\n    return front;\n}\n\nint empty() {\n    return top1 == -1;\n}",
          "timeComplexity": "Push: O(1), Pop: O(n), Peek: O(n)",
          "spaceComplexity": "O(n)"
        }
      ]
    }
  },
  {
    "day": 36,
    "unit": "Unit III: Stack and Queue",
      "question1": {
      "title": "Circular Queue Using Array",
      "description": "Problem: Circular Queue Using Array - Implement using linked list with dynamic memory allocation.\n\nInput:\n- First line: integer n (number of elements to enqueue)\n- Second line: n space-separated integers\n- Third line: integer m (number of dequeue operations)\n\nOutput:\n- Print queue elements from front to rear after operations, space-separated\n\nExample:\nInput:\n5\n10 20 30 40 50\n2\n\nOutput:\n30 40 50 10 20\n\nExplanation:\nUse array and front/rear pointers. Rear wraps around to start after reaching array end. Dequeue removes elements from front. Display remaining elements in correct order."
    },
    "question2": {
      "name": "Design Circular Deque",
      "link": "https://leetcode.com/problems/design-circular-deque/",
      "difficulty": "Medium"
    },
    "topics": [
      "Stack and Queue"
    ],
    "solutions": {
      "question1": [
      {
        "type": "tutorial",
        "explanation": "Implement a Circular Queue using an array with dynamic memory allocation.\n\nApproach:\n- Use a dynamically allocated array of size n.\n- Maintain front and rear pointers along with a count variable.\n- Enqueue inserts at rear using modulo arithmetic.\n- Dequeue removes from front using modulo arithmetic.\n- After dequeue operations, print elements from front to rear in circular order.",
        "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct {\n    int *arr;\n    int front;\n    int rear;\n    int size;\n    int count;\n} CircularQueue;\n\nCircularQueue* createQueue(int n) {\n    CircularQueue* q = (CircularQueue*)malloc(sizeof(CircularQueue));\n    q->size = n;\n    q->arr = (int*)malloc(sizeof(int) * n);\n    q->front = 0;\n    q->rear = -1;\n    q->count = 0;\n    return q;\n}\n\nvoid enqueue(CircularQueue* q, int value) {\n    if (q->count == q->size) return;\n    q->rear = (q->rear + 1) % q->size;\n    q->arr[q->rear] = value;\n    q->count++;\n}\n\nvoid dequeue(CircularQueue* q) {\n    if (q->count == 0) return;\n    q->front = (q->front + 1) % q->size;\n    q->count--;\n}\n\nvoid display(CircularQueue* q) {\n    for (int i = 0; i < q->count; i++) {\n        printf(\"%d \", q->arr[(q->front + i) % q->size]);\n    }\n}\n\nint main() {\n    int n, m, x;\n    scanf(\"%d\", &n);\n\n    CircularQueue* q = createQueue(n);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &x);\n        enqueue(q, x);\n    }\n\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++) {\n        dequeue(q);\n    }\n\n    display(q);\n\n    free(q->arr);\n    free(q);\n    return 0;\n}",
        "timeComplexity": "O(n) for displaying elements",
        "spaceComplexity": "O(n)"
      }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Design Circular Queue Video",
          "link": "https://www.youtube.com/watch?v=kP_nXjMD0w4"
        },
        {
          "type": "tutorial",
          "explanation": "Implement a Circular Deque using an array.\n\nApproach:\n- Use an array of size k+1 to distinguish full and empty states.\n- Maintain two pointers: front (f) and rear (r).\n- Perform insert/delete from both ends using modulo arithmetic.\n- All operations run in constant time.",
          "code": "#include &lt;stdlib.h&gt;\n\ntypedef struct {\n    int* q;\n    int f;\n    int r;\n    int n;\n} MyCircularDeque;\n\nMyCircularDeque* myCircularDequeCreate(int k) {\n    MyCircularDeque* obj = (MyCircularDeque*)malloc(sizeof(MyCircularDeque));\n    obj->n = k + 1;\n    obj->q = (int*)malloc(sizeof(int) * obj->n);\n    obj->f = 0;\n    obj->r = 0;\n    return obj;\n}\n\nint myCircularDequeInsertFront(MyCircularDeque* obj, int value) {\n    if (myCircularDequeIsFull(obj)) return 0;\n    obj->f = (obj->f - 1 + obj->n) % obj->n;\n    obj->q[obj->f] = value;\n    return 1;\n}\n\nint myCircularDequeInsertLast(MyCircularDeque* obj, int value) {\n    if (myCircularDequeIsFull(obj)) return 0;\n    obj->q[obj->r] = value;\n    obj->r = (obj->r + 1) % obj->n;\n    return 1;\n}\n\nint myCircularDequeDeleteFront(MyCircularDeque* obj) {\n    if (myCircularDequeIsEmpty(obj)) return 0;\n    obj->f = (obj->f + 1) % obj->n;\n    return 1;\n}\n\nint myCircularDequeDeleteLast(MyCircularDeque* obj) {\n    if (myCircularDequeIsEmpty(obj)) return 0;\n    obj->r = (obj->r - 1 + obj->n) % obj->n;\n    return 1;\n}\n\nint myCircularDequeGetFront(MyCircularDeque* obj) {\n    if (myCircularDequeIsEmpty(obj)) return -1;\n    return obj->q[obj->f];\n}\n\nint myCircularDequeGetRear(MyCircularDeque* obj) {\n    if (myCircularDequeIsEmpty(obj)) return -1;\n    return obj->q[(obj->r - 1 + obj->n) % obj->n];\n}\n\nint myCircularDequeIsEmpty(MyCircularDeque* obj) {\n    return obj->f == obj->r;\n}\n\nint myCircularDequeIsFull(MyCircularDeque* obj) {\n    return (obj->r + 1) % obj->n == obj->f;\n}\n\nvoid myCircularDequeFree(MyCircularDeque* obj) {\n    free(obj->q);\n    free(obj);\n}",
          "timeComplexity": "O(1) for all operations",
          "spaceComplexity": "O(k)"
        }
      ]
    }
  },
  {
    "day": 37,
    "unit": "Unit III: Stack and Queue",
   "question1": {
      "title": "Priority Queue Using Array",
      "description": "Problem Statement:\nImplement a Priority Queue using an array. An element with smaller value has higher priority.\n\nSupported Operations:\n- insert x\n- delete\n- peek\n\nInput Format:\n- First line contains integer N\n- Next N lines contain operations\n\nOutput Format:\n- Print the deleted or peeked element\n- Print -1 if the queue is empty\n\nExample:\nInput:\n5\ninsert 30\ninsert 10\ninsert 20\ndelete\npeek\n\nOutput:\n10\n20"
    },
    "question2": {
      "name": "Kth Largest Element in a Stream",
      "link": "https://leetcode.com/problems/kth-largest-element-in-a-stream/",
      "difficulty": "Easy"
    },
    "topics": [
      "Stack and Queue"
    ],
    "solutions": {
      "question1": [
      {
        "type": "tutorial",
        "explanation": "A Priority Queue is a data structure where elements are served based on priority instead of insertion order.\n\nIntuition:\n- Higher priority elements are dequeued before lower priority ones.\n- We implement it using an array where insertion keeps elements sorted by priority.\n\nApproach:\n- Each element has a value and a priority.\n- On insertion, place the element at the correct position based on priority.\n- Deletion always removes the element with the highest priority (front of the array).\n\nThis implementation uses a simple array-based approach for clarity.",
        "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define MAX 100\n\ntypedef struct {\n    int value;\n    int priority;\n} PQNode;\n\nPQNode pq[MAX];\nint size = 0;\n\nvoid enqueue(int value, int priority) {\n    int i;\n    if (size == MAX) {\n        printf(\"Priority Queue is full\\n\");\n        return;\n    }\n\n    for (i = size - 1; i >= 0 && pq[i].priority < priority; i--) {\n        pq[i + 1] = pq[i];\n    }\n\n    pq[i + 1].value = value;\n    pq[i + 1].priority = priority;\n    size++;\n}\n\nvoid dequeue() {\n    if (size == 0) {\n        printf(\"Priority Queue is empty\\n\");\n        return;\n    }\n    printf(\"Dequeued: %d\\n\", pq[0].value);\n    for (int i = 0; i < size - 1; i++) {\n        pq[i] = pq[i + 1];\n    }\n    size--;\n}\n\nvoid display() {\n    if (size == 0) {\n        printf(\"Priority Queue is empty\\n\");\n        return;\n    }\n    printf(\"Priority Queue elements:\\n\");\n    for (int i = 0; i < size; i++) {\n        printf(\"Value: %d, Priority: %d\\n\", pq[i].value, pq[i].priority);\n    }\n}\n\nint main() {\n    enqueue(10, 2);\n    enqueue(30, 4);\n    enqueue(20, 3);\n    enqueue(40, 1);\n\n    display();\n\n    dequeue();\n    dequeue();\n\n    display();\n\n    return 0;\n}",
        "timeComplexity": "Enqueue: O(n), Dequeue: O(n)",
        "spaceComplexity": "O(n)"
      }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Kth Largest Element in Array Video",
          "link": "https://www.youtube.com/watch?v=XEmy13g1Qxc"
        },
      {
        "type": "tutorial",
        "explanation": "The KthLargest structure maintains the kth largest element in a stream of integers using a Min-Heap.\n\nIntuition:\n- To efficiently track the kth largest element, we only need the largest k elements seen so far.\n- A Min-Heap of size k is ideal because the smallest element in the heap represents the kth largest overall.\n\nApproach:\n- Use a Min-Heap implemented via an array.\n- While initializing, insert elements into the heap and if the size exceeds k, remove the minimum.\n- When adding a new element, insert it into the heap and again ensure the heap size does not exceed k.\n- The root of the heap always gives the kth largest element.\n\nHeap Operations:\n- Insert: O(log k)\n- Remove Min: O(log k)\n\nThis approach is efficient for continuous streams of data.",
        "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct {\n    int *heap;\n    int size;\n    int capacity;\n} MinHeap;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nMinHeap* createMinHeap(int capacity) {\n    MinHeap* h = (MinHeap*)malloc(sizeof(MinHeap));\n    h->heap = (int*)malloc(sizeof(int) * capacity);\n    h->size = 0;\n    h->capacity = capacity;\n    return h;\n}\n\nvoid heapifyUp(MinHeap* h, int index) {\n    while (index > 0 && h->heap[(index - 1) / 2] > h->heap[index]) {\n        swap(&h->heap[index], &h->heap[(index - 1) / 2]);\n        index = (index - 1) / 2;\n    }\n}\n\nvoid heapifyDown(MinHeap* h, int index) {\n    int smallest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < h->size && h->heap[left] < h->heap[smallest])\n        smallest = left;\n    if (right < h->size && h->heap[right] < h->heap[smallest])\n        smallest = right;\n\n    if (smallest != index) {\n        swap(&h->heap[index], &h->heap[smallest]);\n        heapifyDown(h, smallest);\n    }\n}\n\nvoid insertHeap(MinHeap* h, int val) {\n    if (h->size < h->capacity) {\n        h->heap[h->size++] = val;\n        heapifyUp(h, h->size - 1);\n    } else if (val > h->heap[0]) {\n        h->heap[0] = val;\n        heapifyDown(h, 0);\n    }\n}\n\nint getMin(MinHeap* h) {\n    return h->heap[0];\n}\n\ntypedef struct {\n    MinHeap* heap;\n} KthLargest;\n\nKthLargest* kthLargestCreate(int k, int* nums, int numsSize) {\n    KthLargest* obj = (KthLargest*)malloc(sizeof(KthLargest));\n    obj->heap = createMinHeap(k);\n\n    for (int i = 0; i < numsSize; i++) {\n        insertHeap(obj->heap, nums[i]);\n    }\n    return obj;\n}\n\nint kthLargestAdd(KthLargest* obj, int val) {\n    insertHeap(obj->heap, val);\n    return getMin(obj->heap);\n}\n\nvoid kthLargestFree(KthLargest* obj) {\n    free(obj->heap->heap);\n    free(obj->heap);\n    free(obj);\n}\n\nint main() {\n    int nums[] = {4, 5, 8, 2};\n    int k = 3;\n    int size = sizeof(nums) / sizeof(nums[0]);\n\n    KthLargest* obj = kthLargestCreate(k, nums, size);\n\n    printf(\"%d\\n\", kthLargestAdd(obj, 3));\n    printf(\"%d\\n\", kthLargestAdd(obj, 5));\n    printf(\"%d\\n\", kthLargestAdd(obj, 10));\n    printf(\"%d\\n\", kthLargestAdd(obj, 9));\n    printf(\"%d\\n\", kthLargestAdd(obj, 4));\n\n    kthLargestFree(obj);\n    return 0;\n}",
        "timeComplexity": "O(log k) per insertion",
        "spaceComplexity": "O(k)"
      }
      ]
    }
  },
  {
    "day": 38,
    "unit": "Unit III: Stack and Queue",
  "question1": {
    "title": "Deque Operations",
    "description": "Problem: Deque (Double-Ended Queue)\n\nA Deque is a linear data structure that allows insertion and deletion of elements from both the front and the rear. It provides more flexibility than a standard queue or stack.\n\nCommon Operations:\n1. push_front(value): Insert an element at the front of the deque.\n2. push_back(value): Insert an element at the rear of the deque.\n3. pop_front(): Remove an element from the front of the deque.\n4. pop_back(): Remove an element from the rear of the deque.\n5. front(): Return the front element of the deque.\n6. back(): Return the rear element of the deque.\n7. empty(): Check whether the deque is empty.\n8. size(): Return the number of elements in the deque.\n\nAdditional Operations:\n- clear(): Remove all elements from the deque.\n- erase(): Remove one or more elements from the deque.\n- swap(): Swap contents of two deques.\n- emplace_front(): Insert an element at the front without copying.\n- emplace_back(): Insert an element at the rear without copying.\n- resize(): Change the size of the deque.\n- assign(): Replace elements with new values.\n- reverse(): Reverse the order of elements.\n- sort(): Sort the elements in ascending order.\n\nTime Complexity:\n- push_front, push_back, pop_front, pop_back, front, back, empty, size: O(1)\n- clear, erase, resize, assign, reverse: O(n)\n- sort: O(n log n)\n\nInput:\n- Sequence of deque operations with values (if applicable)\n\nOutput:\n- Results of operations such as front, back, size, or the final state of the deque after all operations"
  },
    "question2": {
      "name": "Sliding Window Maximum",
      "link": "https://leetcode.com/problems/sliding-window-maximum/",
      "difficulty": "Hard"
    },
    "topics": [
      "Stack and Queue"
    ],
    "solutions": {
      "question1": [
      {
        "type": "tutorial",
        "explanation": "Implement a Deque (Double-Ended Queue) using an array in C.\n\nApproach:\n- Use a circular array to efficiently utilize space.\n- Maintain two indices: front and rear.\n- Initially, front = -1 and rear = -1.\n- push_front: Decrement front circularly and insert element.\n- push_back: Increment rear circularly and insert element.\n- pop_front: Remove element at front and move front forward.\n- pop_back: Remove element at rear and move rear backward.\n- Handle overflow (deque full) and underflow (deque empty) conditions.\n- All basic deque operations run in O(1) time.",
        "code": "#include &lt;stdio.h&gt;\n#define MAX 100\n\nint deque[MAX];\nint front = -1, rear = -1;\n\nint isFull() {\n    return ((front == 0 && rear == MAX - 1) || (front == rear + 1));\n}\n\nint isEmpty() {\n    return (front == -1);\n}\n\nvoid push_front(int x) {\n    if (isFull()) {\n        printf(\"Deque Overflow\\n\");\n        return;\n    }\n    if (isEmpty()) {\n        front = rear = 0;\n    } else if (front == 0) {\n        front = MAX - 1;\n    } else {\n        front--;\n    }\n    deque[front] = x;\n}\n\nvoid push_back(int x) {\n    if (isFull()) {\n        printf(\"Deque Overflow\\n\");\n        return;\n    }\n    if (isEmpty()) {\n        front = rear = 0;\n    } else if (rear == MAX - 1) {\n        rear = 0;\n    } else {\n        rear++;\n    }\n    deque[rear] = x;\n}\n\nvoid pop_front() {\n    if (isEmpty()) {\n        printf(\"Deque Underflow\\n\");\n        return;\n    }\n    if (front == rear) {\n        front = rear = -1;\n    } else if (front == MAX - 1) {\n        front = 0;\n    } else {\n        front++;\n    }\n}\n\nvoid pop_back() {\n    if (isEmpty()) {\n        printf(\"Deque Underflow\\n\");\n        return;\n    }\n    if (front == rear) {\n        front = rear = -1;\n    } else if (rear == 0) {\n        rear = MAX - 1;\n    } else {\n        rear--;\n    }\n}\n\nint getFront() {\n    if (isEmpty()) return -1;\n    return deque[front];\n}\n\nint getBack() {\n    if (isEmpty()) return -1;\n    return deque[rear];\n}\n\nint size() {\n    if (isEmpty()) return 0;\n    if (rear >= front)\n        return rear - front + 1;\n    return MAX - front + rear + 1;\n}\n\nvoid display() {\n    if (isEmpty()) {\n        printf(\"Deque is empty\\n\");\n        return;\n    }\n    int i = front;\n    while (1) {\n        printf(\"%d \", deque[i]);\n        if (i == rear) break;\n        i = (i + 1) % MAX;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    push_back(10);\n    push_back(20);\n    push_front(5);\n    push_back(30);\n\n    display();\n\n    pop_front();\n    pop_back();\n\n    display();\n\n    printf(\"Front: %d\\n\", getFront());\n    printf(\"Back: %d\\n\", getBack());\n    printf(\"Size: %d\\n\", size());\n\n    return 0;\n}",
        "timeComplexity": "O(1) for push_front, push_back, pop_front, pop_back, front, back, size",
        "spaceComplexity": "O(n) where n is the maximum size of the deque"
      }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Sliding Window Maximum Video",
          "link": "https://www.youtube.com/watch?v=DfljaUwZsOk"
        },
        {
          "type": "tutorial",
          "explanation": "Sliding Window Maximum using Monotonic Deque (C Implementation).\n\nApproach:\n- Use a deque that stores indices of elements.\n- The deque is maintained in decreasing order of values.\n- Front of deque always stores the index of the maximum element of the current window.\n\nSteps:\n1. Remove indices from the front that are out of the current window (i - k).\n2. Remove indices from the back whose corresponding values are smaller than the current element, as they cannot be maximum anymore.\n3. Insert the current index at the back.\n4. Once the first window is completed (i >= k - 1), store the value at the front index as the maximum.\n\nThis ensures each element is pushed and popped at most once.",
          "code": "#include &lt;stdio.h&gt;\n\n#define MAX 10000\n\nint deque[MAX];\nint front = 0, rear = -1;\n\nint isEmpty() {\n    return front > rear;\n}\n\nvoid popFront() {\n    front++;\n}\n\nvoid popBack() {\n    rear--;\n}\n\nvoid pushBack(int x) {\n    deque[++rear] = x;\n}\n\nint getFront() {\n    return deque[front];\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d\", &n);\n\n    int nums[n];\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &nums[i]);\n\n    scanf(\"%d\", &k);\n\n    int result[n];\n    int resSize = 0;\n\n    for (int i = 0; i < n; i++) {\n        /* Remove indices out of current window */\n        if (!isEmpty() && getFront() <= i - k)\n            popFront();\n\n        /* Remove smaller elements */\n        while (!isEmpty() && nums[deque[rear]] < nums[i])\n            popBack();\n\n        pushBack(i);\n\n        /* Store result once first window is complete */\n        if (i >= k - 1)\n            result[resSize++] = nums[getFront()];\n    }\n\n    /* Print result */\n    for (int i = 0; i < resSize; i++)\n        printf(\"%d \", result[i]);\n\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(k)"
        }
      ]
    }
  },
  {
    "day": 39,
    "unit": "Unit III: Stack and Queue",
    "question1": {
      "title": "Min Heap Implementation",
      "description": "Problem Statement:\nImplement a Min Heap using an array where the smallest element is always at the root.\n\nSupported Operations:\n- insert x\n- extractMin\n- peek\n\nInput Format:\n- First line contains integer N\n- Next N lines contain heap operations\n\nOutput Format:\n- Print results of extractMin and peek\n- Print -1 if operation cannot be performed\n\nExample:\nInput:\n6\ninsert 40\ninsert 10\ninsert 30\npeek\nextractMin\npeek\n\nOutput:\n10\n10\n30"
    },
    "question2": {
      "name": "Top K Frequent Elements",
      "link": "https://leetcode.com/problems/top-k-frequent-elements/",
      "difficulty": "Medium"
    },
    "topics": ["Heap", "Priority Queue"],
    "solutions": {
      "question1": [
        {
        "type": "tutorial",
        "explanation": "A Min Heap is a complete binary tree where the smallest element is always at the root.\n\nIntuition:\n- The minimum element should be accessible in O(1) time.\n- Use an array to represent the heap structure.\n\nApproach:\n- Insert elements at the end and fix heap property using heapify-up.\n- Remove the minimum (root) and restore heap using heapify-down.\n- Heap is stored as an array where:\n  - Parent index = (i - 1) / 2\n  - Left child = 2*i + 1\n  - Right child = 2*i + 2",
        "code": "#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX 1000\n\nint heap[MAX];\nint size = 0;\n\nvoid swap(int *a, int *b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid heapifyUp(int index) {\n    while (index > 0) {\n        int parent = (index - 1) / 2;\n        if (heap[parent] > heap[index]) {\n            swap(&heap[parent], &heap[index]);\n            index = parent;\n        } else break;\n    }\n}\n\nvoid heapifyDown(int index) {\n    while (1) {\n        int smallest = index;\n        int left = 2 * index + 1;\n        int right = 2 * index + 2;\n\n        if (left < size && heap[left] < heap[smallest]) smallest = left;\n        if (right < size && heap[right] < heap[smallest]) smallest = right;\n\n        if (smallest != index) {\n            swap(&heap[index], &heap[smallest]);\n            index = smallest;\n        } else break;\n    }\n}\n\nvoid insert(int x) {\n    heap[size] = x;\n    heapifyUp(size);\n    size++;\n}\n\nvoid extractMin() {\n    if (size == 0) {\n        printf(\"-1\\n\");\n        return;\n    }\n    printf(\"%d\\n\", heap[0]);\n    heap[0] = heap[size - 1];\n    size--;\n    heapifyDown(0);\n}\n\nvoid peek() {\n    if (size == 0) {\n        printf(\"-1\\n\");\n        return;\n    }\n    printf(\"%d\\n\", heap[0]);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char op[20];\n    int x;\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", op);\n        if (strcmp(op, \"insert\") == 0) {\n            scanf(\"%d\", &x);\n            insert(x);\n        } else if (strcmp(op, \"extractMin\") == 0) {\n            extractMin();\n        } else if (strcmp(op, \"peek\") == 0) {\n            peek();\n        }\n    }\n    return 0;\n}",
        "timeComplexity": "Insert: O(log n), ExtractMin: O(log n), Peek: O(1)",
        "spaceComplexity": "O(n)"
        }

      ],
      "question2": [
        {
          "type": "video",
          "label": "Top K Frequent Elements",
          "link": "https://www.youtube.com/watch?v=YPTqKIgVk-k"
        },
      {
      "type": "tutorial",
      "explanation": "Find the k most frequent elements in an array.\n\nApproach:\n- Use a hash table to count frequency of each element in O(n).\n- Use a min-heap (priority queue) of size k to keep only top k frequent elements.\n- If heap size exceeds k, remove the element with smallest frequency.\n- Finally, heap contains k most frequent elements.",
      "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define MAX 10000\n\n/* Hash table node */\ntypedef struct {\n    int key;\n    int freq;\n} HashNode;\n\nHashNode hash[MAX];\nint hashSize = 0;\n\nint findIndex(int key) {\n    for (int i = 0; i < hashSize; i++) {\n        if (hash[i].key == key)\n            return i;\n    }\n    return -1;\n}\n\n/* Min Heap node */\ntypedef struct {\n    int freq;\n    int val;\n} HeapNode;\n\nHeapNode heap[MAX];\nint heapSize = 0;\n\nvoid swap(HeapNode *a, HeapNode *b) {\n    HeapNode t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid heapifyUp(int i) {\n    while (i > 0) {\n        int p = (i - 1) / 2;\n        if (heap[p].freq > heap[i].freq) {\n            swap(&heap[p], &heap[i]);\n            i = p;\n        } else break;\n    }\n}\n\nvoid heapifyDown(int i) {\n    while (1) {\n        int smallest = i;\n        int l = 2*i + 1, r = 2*i + 2;\n        if (l < heapSize && heap[l].freq < heap[smallest].freq)\n            smallest = l;\n        if (r < heapSize && heap[r].freq < heap[smallest].freq)\n            smallest = r;\n        if (smallest != i) {\n            swap(&heap[i], &heap[smallest]);\n            i = smallest;\n        } else break;\n    }\n}\n\nvoid pushHeap(int freq, int val, int k) {\n    heap[heapSize++] = (HeapNode){freq, val};\n    heapifyUp(heapSize - 1);\n\n    if (heapSize > k) {\n        heap[0] = heap[heapSize - 1];\n        heapSize--;\n        heapifyDown(0);\n    }\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d\", &n);\n\n    int nums[n];\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &nums[i]);\n\n    scanf(\"%d\", &k);\n\n    /* Frequency counting */\n    for (int i = 0; i < n; i++) {\n        int idx = findIndex(nums[i]);\n        if (idx == -1)\n            hash[hashSize++] = (HashNode){nums[i], 1};\n        else\n            hash[idx].freq++;\n    }\n\n    /* Build min-heap of size k */\n    for (int i = 0; i < hashSize; i++) {\n        pushHeap(hash[i].freq, hash[i].key, k);\n    }\n\n    /* Output result */\n    for (int i = 0; i < heapSize; i++) {\n        printf(\"%d \", heap[i].val);\n    }\n\n    return 0;\n}",
      "timeComplexity": "O(n + m log k)",
      "spaceComplexity": "O(m + k)"
      }
      ]
    }
  },
  {
  "day": 40,
  "unit": "Unit III: Stack & Queue",
  "question1": {
    "title": "Heap Sort Using Max-Heap",
    "description": "Implement Heap Sort using a Max Heap to sort an array in ascending order. First build a max heap, then repeatedly extract the maximum element and place it at the end of the array."
  },
  "question2": {
    "name": "Daily Temperatures",
    "link": "https://leetcode.com/problems/daily-temperatures/",
    "difficulty": "Medium"
  },
  "topics": [
    "Heap Sort",
    "Max Heap",
    "Sorting"
  ],
  "solutions": {
    "question1": [
      {
        "type": "tutorial",
        "explanation": "Heap Sort works by first converting the array into a Max Heap, where the largest element is at the root. The root element is swapped with the last element of the array, the heap size is reduced, and heapify is applied again. This process continues until the array is fully sorted.",
        "code": "#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left &lt; n && arr[left] &gt; arr[largest])\n        largest = left;\n    if (right &lt; n && arr[right] &gt; arr[largest])\n        largest = right;\n\n    if (largest != i) {\n        swap(&arr[i], &arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i &gt;= 0; i--)\n        heapify(arr, n, i);\n\n    for (int i = n - 1; i &gt; 0; i--) {\n        swap(&arr[0], &arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int arr[n];\n    for (int i = 0; i &lt; n; i++)\n        scanf(\"%d\", &arr[i]);\n\n    heapSort(arr, n);\n\n    for (int i = 0; i &lt; n; i++)\n        printf(\"%d \", arr[i]);\n\n    return 0;\n}",
        "timeComplexity": "O(N log N)",
        "spaceComplexity": "O(1)"
      }
    ],
    "question2": [
      {
        "type": "tutorial",
        "explanation": "This problem uses a monotonic decreasing stack. We traverse the temperature array from right to left and maintain indices of days with higher temperatures. For each day, we pop all indices with temperatures less than or equal to the current day and calculate the difference to find the next warmer day.",
        "code": "#include &lt;stdlib.h&gt;\n\nint* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize) {\n    int n = temperaturesSize;\n    int* ans = (int*)malloc(n * sizeof(int));\n    int* stack = (int*)malloc(n * sizeof(int));\n    int top = -1;\n\n    for (int i = n - 1; i &gt;= 0; i--) {\n        while (top != -1 && temperatures[i] &gt;= temperatures[stack[top]]) {\n            top--;\n        }\n        ans[i] = (top != -1) ? stack[top] - i : 0;\n        stack[++top] = i;\n    }\n\n    *returnSize = n;\n    free(stack);\n    return ans;\n}",
        "timeComplexity": "O(N)",
        "spaceComplexity": "O(N)"
      },
      {
        "type": "video",
        "label": "Daily Temperatures Explanation",
        "link": "https://www.youtube.com/watch?v=cTBiBSnjO3c"
      }
    ]
  }
},
  {
    "day": 41,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Queue Using Linked List",
      "description": "Problem Statement:\nImplement a Queue using a linked list supporting enqueue and dequeue operations.\n\nInput Format:\n- First line contains integer N\n- Next N lines contain queue operations\n\nOutput Format:\n- Print dequeued elements\n- Print -1 if dequeue is attempted on an empty queue"
    },
    "question2": {
      "name": "Task Scheduler",
      "link": "https://leetcode.com/problems/task-scheduler/",
      "difficulty": "Medium"
    },
    "topics": [
      "Queue",
      "Linked List Implementation"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "A queue follows the FIFO (First In First Out) principle. In this implementation, a linked list is used to create a dynamic queue.\n\nThe queue maintains two pointers:\n- front points to the first element\n- rear points to the last element\n\nEnqueue:\nA new node is created and added at the rear. If the queue is empty, both front and rear point to the new node.\n\nDequeue:\nThe element at the front is removed and front is moved to the next node. If the queue becomes empty, rear is set to NULL.\n\nUsing a linked list avoids overflow issues and allows dynamic memory allocation. Both enqueue and dequeue operations take O(1) time.",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include <stdlib.h>\n\n/* Node structure */\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\n/* Queue structure */\ntypedef struct myQueue {\n    int currSize;\n    Node* front;\n    Node* rear;\n} myQueue;\n\nNode* newNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    if (node == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    node->data = data;\n    node->next = NULL;\n    return node;\n}\n\nmyQueue* createQueue() {\n    myQueue* q = (myQueue*)malloc(sizeof(myQueue));\n    if (q == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    q->front = NULL;\n    q->rear = NULL;\n    q->currSize = 0;\n    return q;\n}\n\nint isEmpty(myQueue* q) {\n    return q->front == NULL;\n}\n\nvoid enqueue(myQueue* q, int data) {\n    Node* node = newNode(data);\n    if (isEmpty(q)) {\n        q->front = q->rear = node;\n    } else {\n        q->rear->next = node;\n        q->rear = node;\n    }\n    q->currSize++;\n}\n\nint dequeue(myQueue* q) {\n    if (isEmpty(q)) {\n        return -1;\n    }\n    Node* temp = q->front;\n    int removedData = temp->data;\n    q->front = q->front->next;\n    if (q->front == NULL)\n        q->rear = NULL;\n    free(temp);\n    q->currSize--;\n    return removedData;\n}",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Task Scheduler Explanation",
          "link": "https://www.youtube.com/watch?v=rYh-Kkbzsnw"
        },
        {
          "type": "tutorial",
          "explanation": "Brute-force simulation approach:\n\nAt each time unit, select the available task with the highest remaining frequency. If no task is available, the CPU stays idle. Cooldown time is maintained for each task and reduced after every time unit. The process continues until all tasks are completed.",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint allDone(int freq[]) {\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > 0)\n            return 0;\n    }\n    return 1;\n}\n\nint leastInterval(char* tasks, int tasksSize, int n) {\n    int freq[26] = {0};\n    int cooldown[26] = {0};\n\n    for (int i = 0; i < tasksSize; i++) {\n        freq[tasks[i] - 'A']++;\n    }\n\n    int time = 0;\n\n    while (!allDone(freq)) {\n        int taskIndex = -1;\n        int maxFreq = 0;\n\n        for (int i = 0; i < 26; i++) {\n            if (freq[i] > 0 && cooldown[i] == 0 && freq[i] > maxFreq) {\n                maxFreq = freq[i];\n                taskIndex = i;\n            }\n        }\n\n        if (taskIndex != -1) {\n            freq[taskIndex]--;\n            cooldown[taskIndex] = n + 1;\n        }\n\n        for (int i = 0; i < 26; i++) {\n            if (cooldown[i] > 0)\n                cooldown[i]--;\n        }\n\n        time++;\n    }\n\n    return time;\n}",
          "timeComplexity": "O(T × 26)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 42,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Reverse a Queue Using Stack",
      "description": "Problem Statement:\nGiven a queue of integers, reverse the queue using a stack.\n\nInput Format:\n- First line contains integer N\n- Second line contains N space-separated integers\n\nOutput Format:\n- Print the reversed queue\n\nExample:\nInput:\n5\n10 20 30 40 50\n\nOutput:\n50 40 30 20 10"
    },
    "question2": {
      "name": "Find Median from Data Stream",
      "link": "https://leetcode.com/problems/find-median-from-data-stream/",
      "difficulty": "Hard"
    },
    "topics": [
      "Queue",
      "Stack",
      "Reversal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To reverse a queue, a stack is used as an auxiliary data structure. First, all elements are dequeued from the queue and pushed onto the stack. Because the stack follows the LIFO principle, the order of elements is reversed. Next, all elements are popped from the stack and enqueued back into the queue. After this process, the queue elements appear in reverse order.",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n/* Queue Node */\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\n/* Queue structure */\ntypedef struct Queue {\n    Node* front;\n    Node* rear;\n} Queue;\n\n/* Stack Node */\ntypedef struct Stack {\n    int data;\n    struct Stack* next;\n} Stack;\n\nQueue* createQueue() {\n    Queue* q = (Queue*)malloc(sizeof(Queue));\n    q->front = q->rear = NULL;\n    return q;\n}\n\nvoid enqueue(Queue* q, int x) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->data = x;\n    node->next = NULL;\n\n    if (q->rear == NULL) {\n        q->front = q->rear = node;\n        return;\n    }\n    q->rear->next = node;\n    q->rear = node;\n}\n\nint dequeue(Queue* q) {\n    if (q->front == NULL)\n        return -1;\n\n    Node* temp = q->front;\n    int val = temp->data;\n    q->front = q->front->next;\n\n    if (q->front == NULL)\n        q->rear = NULL;\n\n    free(temp);\n    return val;\n}\n\nvoid push(Stack** top, int x) {\n    Stack* node = (Stack*)malloc(sizeof(Stack));\n    node->data = x;\n    node->next = *top;\n    *top = node;\n}\n\nint pop(Stack** top) {\n    if (*top == NULL)\n        return -1;\n\n    Stack* temp = *top;\n    int val = temp->data;\n    *top = temp->next;\n    free(temp);\n    return val;\n}\n\nvoid reverseQueue(Queue* q) {\n    Stack* stack = NULL;\n\n    while (q->front != NULL) {\n        push(&stack, dequeue(q));\n    }\n\n    while (stack != NULL) {\n        enqueue(q, pop(&stack));\n    }\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Find Median from Data Stream Explanation",
          "link": "https://www.youtube.com/watch?v=itmhHWaHupI"
        },
        {
          "type": "tutorial",
          "explanation": "The median is maintained using two heaps. A max heap stores the smaller half of the numbers and a min heap stores the larger half. New numbers are inserted into the appropriate heap and the heaps are balanced so that their size difference is at most one. The median is either the top of the max heap or the average of both heap tops.",
          "code": "#include &lt;stdlib.h&gt;\n\n/* Heap structure */\ntypedef struct {\n    int* arr;\n    int size;\n    int capacity;\n    int isMinHeap;\n} Heap;\n\n/* MedianFinder */\ntypedef struct {\n    Heap* left;\n    Heap* right;\n} MedianFinder;\n\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nHeap* createHeap(int capacity, int isMinHeap) {\n    Heap* h = (Heap*)malloc(sizeof(Heap));\n    h->capacity = capacity;\n    h->size = 0;\n    h->isMinHeap = isMinHeap;\n    h->arr = (int*)malloc(sizeof(int) * capacity);\n    return h;\n}\n\nvoid ensureCapacity(Heap* h) {\n    if (h->size < h->capacity) return;\n    h->capacity *= 2;\n    h->arr = (int*)realloc(h->arr, sizeof(int) * h->capacity);\n}\n\nint compare(Heap* h, int a, int b) {\n    return h->isMinHeap ? a < b : a > b;\n}\n\nvoid heapifyUp(Heap* h, int i) {\n    while (i > 0) {\n        int p = (i - 1) / 2;\n        if (compare(h, h->arr[i], h->arr[p])) {\n            swap(&h->arr[i], &h->arr[p]);\n            i = p;\n        } else break;\n    }\n}\n\nvoid heapifyDown(Heap* h, int i) {\n    while (1) {\n        int l = 2*i + 1, r = 2*i + 2, best = i;\n        if (l < h->size && compare(h, h->arr[l], h->arr[best])) best = l;\n        if (r < h->size && compare(h, h->arr[r], h->arr[best])) best = r;\n        if (best != i) {\n            swap(&h->arr[i], &h->arr[best]);\n            i = best;\n        } else break;\n    }\n}\n\nvoid heapPush(Heap* h, int val) {\n    ensureCapacity(h);\n    h->arr[h->size] = val;\n    heapifyUp(h, h->size);\n    h->size++;\n}\n\nint heapPop(Heap* h) {\n    int top = h->arr[0];\n    h->arr[0] = h->arr[h->size - 1];\n    h->size--;\n    heapifyDown(h, 0);\n    return top;\n}\n\nint heapTop(Heap* h) {\n    return h->arr[0];\n}\n\nMedianFinder* medianFinderCreate() {\n    MedianFinder* obj = (MedianFinder*)malloc(sizeof(MedianFinder));\n    obj->left = createHeap(16, 0);\n    obj->right = createHeap(16, 1);\n    return obj;\n}\n\nvoid medianFinderAddNum(MedianFinder* obj, int num) {\n    if (obj->left->size == 0 || num <= heapTop(obj->left))\n        heapPush(obj->left, num);\n    else\n        heapPush(obj->right, num);\n\n    if (obj->left->size > obj->right->size + 1)\n        heapPush(obj->right, heapPop(obj->left));\n    else if (obj->right->size > obj->left->size)\n        heapPush(obj->left, heapPop(obj->right));\n}\n\ndouble medianFinderFindMedian(MedianFinder* obj) {\n    if (obj->left->size > obj->right->size)\n        return heapTop(obj->left);\n    return (heapTop(obj->left) + heapTop(obj->right)) / 2.0;\n}\n\nvoid medianFinderFree(MedianFinder* obj) {\n    free(obj->left->arr);\n    free(obj->right->arr);\n    free(obj->left);\n    free(obj->right);\n    free(obj);\n}",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(n)"
        }
      ]
    }
  },
  {
    "day": 43,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Binary Tree Construction (Level Order)",
      "description": "Problem Statement:\nConstruct a Binary Tree from the given level-order traversal.\n\nInput Format:\n- First line contains integer N\n- Second line contains N space-separated integers (-1 represents NULL)\n\nOutput Format:\n- Print inorder traversal of the constructed tree\n\nExample:\nInput:\n7\n1 2 3 4 5 -1 6\n\nOutput:\n4 2 5 1 3 6"
    },
    "question2": {
      "name": "Binary Tree Inorder Traversal",
      "link": "https://leetcode.com/problems/binary-tree-inorder-traversal/",
      "difficulty": "Easy"
    },
    "topics": [
      "Binary Tree",
      "Construction",
      "Traversal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "In level order traversal, nodes are given from top to bottom and left to right. The first element represents the root. A queue is used to assign left and right children level by level until all nodes are inserted.",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nstruct Node* buildTree(int arr[], int n) {\n    if (n == 0) return NULL;\n\n    struct Node* root = createNode(arr[0]);\n    struct Node* queue[n];\n    int front = 0, rear = 0;\n\n    queue[rear++] = root;\n    int i = 1;\n\n    while (i < n) {\n        struct Node* current = queue[front++];\n\n        if (i < n) {\n            current->left = createNode(arr[i++]);\n            queue[rear++] = current->left;\n        }\n        if (i < n) {\n            current->right = createNode(arr[i++]);\n            queue[rear++] = current->right;\n        }\n    }\n    return root;\n}\n\nvoid inorder(struct Node* root) {\n    if (root == NULL) return;\n    inorder(root->left);\n    printf(\"%d \", root->data);\n    inorder(root->right);\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Binary Tree Inorder Traversal",
          "link": "https://www.youtube.com/watch?v=NQjAvtyLFM0"
        },
        {
          "type": "tutorial",
          "explanation": "In inorder traversal, nodes are visited in the order: left subtree, root, and right subtree. A recursive approach is used to traverse the tree and store node values in the result array.",
          "code": "int inorder(int* arr, struct TreeNode* root, int index) {\n    if (root != NULL) {\n        index = inorder(arr, root->left, index);\n        arr[index++] = root->val;\n        index = inorder(arr, root->right, index);\n    }\n    return index;\n}\n\nint* inorderTraversal(struct TreeNode* root, int* returnSize) {\n    int* arr = (int*)malloc(100 * sizeof(int));\n    *returnSize = inorder(arr, root, 0);\n    return arr;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ]
    }
  },
  {
    "day": 44,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Binary Tree Traversals",
      "description": "Problem Statement:\nPerform inorder, preorder, and postorder traversals of a given binary tree.\n\nInput Format:\n- First line contains integer N\n- Second line contains level-order traversal (-1 represents NULL)\n\nOutput Format:\n- Print inorder, preorder, and postorder traversals\n\nExample:\nInput:\n7\n1 2 3 4 5 6 7\n\nOutput:\n4 2 5 1 6 3 7\n1 2 4 5 3 6 7\n4 5 2 6 7 3 1"
    },
    "question2": {
      "name": "Binary Tree Preorder Traversal",
      "link": "https://leetcode.com/problems/binary-tree-preorder-traversal/",
      "difficulty": "Easy"
    },
    "topics": [
      "Tree Traversal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "The binary tree is first constructed using level-order traversal with the help of a queue. The first element becomes the root, and subsequent elements are assigned as left and right children. Nodes with value -1 are treated as NULL and skipped.\n\nAfter constructing the tree, three recursive traversals are performed:\n- Inorder: Left → Root → Right\n- Preorder: Root → Left → Right\n- Postorder: Left → Right → Root",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nstruct Node* buildTree(int arr[], int n) {\n    if (n == 0 || arr[0] == -1)\n        return NULL;\n\n    struct Node* root = createNode(arr[0]);\n    struct Node* queue[n];\n    int front = 0, rear = 0;\n\n    queue[rear++] = root;\n    int i = 1;\n\n    while (i < n) {\n        struct Node* current = queue[front++];\n\n        if (i < n && arr[i] != -1) {\n            current->left = createNode(arr[i]);\n            queue[rear++] = current->left;\n        }\n        i++;\n\n        if (i < n && arr[i] != -1) {\n            current->right = createNode(arr[i]);\n            queue[rear++] = current->right;\n        }\n        i++;\n    }\n    return root;\n}\n\nvoid inorder(struct Node* root) {\n    if (root == NULL) return;\n    inorder(root->left);\n    printf(\"%d \", root->data);\n    inorder(root->right);\n}\n\nvoid preorder(struct Node* root) {\n    if (root == NULL) return;\n    printf(\"%d \", root->data);\n    preorder(root->left);\n    preorder(root->right);\n}\n\nvoid postorder(struct Node* root) {\n    if (root == NULL) return;\n    postorder(root->left);\n    postorder(root->right);\n    printf(\"%d \", root->data);\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Binary Tree Inorder & Preorder Traversal",
          "link": "https://www.youtube.com/watch?v=NQjAvtyLFM0"
        },
        {
          "type": "tutorial",
          "explanation": "Preorder traversal visits nodes in the order Root → Left → Right. A recursive helper function stores node values in an array while traversing the tree.",
          "code": "int preorder(int* arr, struct TreeNode* root, int index) {\n    if (root != NULL) {\n        arr[index++] = root->val;\n        index = preorder(arr, root->left, index);\n        index = preorder(arr, root->right, index);\n    }\n    return index;\n}\n\nint* preorderTraversal(struct TreeNode* root, int* returnSize) {\n    int* arr = (int*)malloc(100 * sizeof(int));\n    *returnSize = preorder(arr, root, 0);\n    return arr;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ]
    }
  },
  {
    "day": 45,
    "unit": "Unit III: Stack & Queue",
    "question1": {
      "title": "Height of a Binary Tree",
      "description": "Problem Statement:\nFind the height (maximum depth) of a given binary tree.\n\nInput Format:\n- First line contains integer N\n- Second line contains level-order traversal (-1 represents NULL)\n\nOutput Format:\n- Print the height of the tree\n\nExample:\nInput:\n7\n1 2 3 4 5 -1 -1\n\nOutput:\n3"
    },
    "question2": {
      "name": "Maximum Depth of Binary Tree",
      "link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
      "difficulty": "Easy"
    },
    "topics": [
      "Binary Tree",
      "Recursion"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "The height of a binary tree is defined as the number of nodes on the longest path from the root to a leaf node. The height can be calculated recursively. If the current node is NULL, the height is 0. Otherwise, the height is 1 plus the maximum height of its left and right subtrees.",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nint height(struct Node* root) {\n    if (root == NULL)\n        return 0;\n\n    int leftHeight = height(root->left);\n    int rightHeight = height(root->right);\n\n    return 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Maximum Depth of Binary Tree Explanation",
          "link": "https://www.youtube.com/watch?v=o2LEC2NEVuk"
        },
        {
          "type": "tutorial",
          "explanation": "The maximum depth of a binary tree is found using recursion. For each node, compute the depth of its left and right subtrees and return the larger value plus one. If the node is NULL, the depth is zero.",
          "code": "int maxDepth(struct TreeNode* root) {\n    if (root == NULL)\n        return 0;\n\n    int leftDepth = maxDepth(root->left);\n    int rightDepth = maxDepth(root->right);\n\n    return (leftDepth > rightDepth ? leftDepth : rightDepth) + 1;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)"
        }
      ]
    }
  },
  {
    "day": 46,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Level Order Traversal",
      "description": "Problem: Level Order Traversal\n\nImplement the solution for this problem.\n\nInput:\n- Input specifications\n\nOutput:\n- Output specifications"
    },
    "question2": {
      "name": "Binary Tree Level Order Traversal",
      "link": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
      "difficulty": "Medium"
    },
    "topics": [
      "Tree"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution for Level Order Traversal:\n\n1. Understand the problem\n2. Implement the algorithm\n3. Test with examples\n\nKey Points:\n- Use appropriate data structure\n- Handle edge cases\n- Optimize where possible",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Level Order Traversal implementation\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    // Implementation here\n    printf(\"Result\\n\");\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Binary Tree Level Order Traversal Video",
          "link": "https://www.youtube.com/results?search_query=Binary+Tree+Level+Order+Traversal+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution for Binary Tree Level Order Traversal",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Binary Tree Level Order Traversal solution in C",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 47,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Height of Binary Tree",
      "description": "Problem: Height of Binary Tree\n\nImplement the solution for this problem.\n\nInput:\n- Input specifications\n\nOutput:\n- Output specifications"
    },
    "question2": {
      "name": "Maximum Depth of Binary Tree",
      "link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
      "difficulty": "Easy"
    },
    "topics": [
      "Tree"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution for Height of Binary Tree:\n\n1. Understand the problem\n2. Implement the algorithm\n3. Test with examples\n\nKey Points:\n- Use appropriate data structure\n- Handle edge cases\n- Optimize where possible",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Height of Binary Tree implementation\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    // Implementation here\n    printf(\"Result\\n\");\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Maximum Depth of Binary Tree Video",
          "link": "https://www.youtube.com/results?search_query=Maximum+Depth+of+Binary+Tree+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution for Maximum Depth of Binary Tree",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Maximum Depth of Binary Tree solution in C",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 48,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "Count Leaf Nodes",
      "description": "Problem: Count Leaf Nodes\n\nImplement the solution for this problem.\n\nInput:\n- Input specifications\n\nOutput:\n- Output specifications"
    },
    "question2": {
      "name": "Sum of Left Leaves",
      "link": "https://leetcode.com/problems/sum-of-left-leaves/",
      "difficulty": "Easy"
    },
    "topics": [
      "Tree"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution for Count Leaf Nodes:\n\n1. Understand the problem\n2. Implement the algorithm\n3. Test with examples\n\nKey Points:\n- Use appropriate data structure\n- Handle edge cases\n- Optimize where possible",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Count Leaf Nodes implementation\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    // Implementation here\n    printf(\"Result\\n\");\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Sum of Left Leaves Video",
          "link": "https://www.youtube.com/results?search_query=Sum+of+Left+Leaves+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution for Sum of Left Leaves",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Sum of Left Leaves solution in C",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 49,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "BST Insert",
      "description": "Problem: BST Insert\n\nImplement the solution for this problem.\n\nInput:\n- Input specifications\n\nOutput:\n- Output specifications"
    },
    "question2": {
      "name": "Insert into BST",
      "link": "https://leetcode.com/problems/insert-into-bst/",
      "difficulty": "Medium"
    },
    "topics": [
      "Tree"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution for BST Insert:\n\n1. Understand the problem\n2. Implement the algorithm\n3. Test with examples\n\nKey Points:\n- Use appropriate data structure\n- Handle edge cases\n- Optimize where possible",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// BST Insert implementation\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    // Implementation here\n    printf(\"Result\\n\");\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Insert into BST Video",
          "link": "https://www.youtube.com/results?search_query=Insert+into+BST+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution for Insert into BST",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Insert into BST solution in C",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 50,
    "unit": "Unit IV: Tree",
    "question1": {
      "title": "BST Search",
      "description": "Problem: BST Search\n\nImplement the solution for this problem.\n\nInput:\n- Input specifications\n\nOutput:\n- Output specifications"
    },
    "question2": {
      "name": "Search in BST",
      "link": "https://leetcode.com/problems/search-in-bst/",
      "difficulty": "Easy"
    },
    "topics": [
      "Tree"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Solution for BST Search:\n\n1. Understand the problem\n2. Implement the algorithm\n3. Test with examples\n\nKey Points:\n- Use appropriate data structure\n- Handle edge cases\n- Optimize where possible",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// BST Search implementation\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    // Implementation here\n    printf(\"Result\\n\");\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Search in BST Video",
          "link": "https://www.youtube.com/results?search_query=Search+in+BST+leetcode"
        },
        {
          "type": "tutorial",
          "explanation": "Solution for Search in BST",
          "code": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Search in BST solution in C",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  }
]